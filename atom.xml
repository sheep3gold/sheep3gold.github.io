<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>yangxin&#39;s blogs</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2019-01-17T06:53:07.854Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>dream</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>springcloud2</title>
    <link href="http://yoursite.com/2019/01/17/springcloud2/"/>
    <id>http://yoursite.com/2019/01/17/springcloud2/</id>
    <published>2019-01-17T06:50:47.000Z</published>
    <updated>2019-01-17T06:53:07.854Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud基础学习-续"><a href="#SpringCloud基础学习-续" class="headerlink" title="SpringCloud基础学习(续)"></a>SpringCloud基础学习(续)</h1><a id="more"></a><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>会使用Feign进行远程调用</li><li>能独立搭建Zuul网关</li><li>能编写Zuul的拦截器</li></ul><h1 id="1-Feign"><a href="#1-Feign" class="headerlink" title="1.Feign"></a>1.Feign</h1><p>在前面的学习中，我们使用了Ribbon的负载均衡功能，大大简化了远程调用时的代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String baseUrl = <span class="string">"http://user-service/user/"</span>;</span><br><span class="line">User user = <span class="keyword">this</span>.restTemplate.getForObject(baseUrl + id, User.class)</span><br></pre></td></tr></table></figure><p>如果就学到这里，你可能以后需要编写类似的大量重复代码，格式基本相同，无非参数不一样。有没有更优雅的方式，来对这些代码再次优化呢？</p><p>这就是我们接下来要学的Feign的功能了。</p><h2 id="1-1-简介"><a href="#1-1-简介" class="headerlink" title="1.1.简介"></a>1.1.简介</h2><p>有道词典的英文解释：</p><p>​    <img src="\blogPic\springcloud2\1525662976679.png" alt="1525662976679"></p><p>为什么叫伪装？</p><p>Feign可以把Rest的请求进行隐藏，伪装成类似SpringMVC的Controller一样。你不用再自己拼接url，拼接参数等等操作，一切都交给Feign去做。</p><p>项目主页：<a href="https://github.com/OpenFeign/feign" target="_blank" rel="noopener">https://github.com/OpenFeign/feign</a></p><h2 id="1-2-快速入门"><a href="#1-2-快速入门" class="headerlink" title="1.2.快速入门"></a>1.2.快速入门</h2><h3 id="1-2-1-导入依赖"><a href="#1-2-1-导入依赖" class="headerlink" title="1.2.1.导入依赖"></a>1.2.1.导入依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-openfeign<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="1-2-2-Feign的客户端"><a href="#1-2-2-Feign的客户端" class="headerlink" title="1.2.2.Feign的客户端"></a>1.2.2.Feign的客户端</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(<span class="string">"user-service"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>首先这是一个接口，Feign会通过动态代理，帮我们生成实现类。这点跟mybatis的mapper很像</li><li><code>@FeignClient</code>，声明这是一个Feign客户端，同时通过<code>value</code>属性指定服务名称</li><li>接口中的定义方法，完全采用SpringMVC的注解，Feign会根据注解帮我们生成URL，并访问获取结果</li></ul><p>改造原来的调用逻辑，使用UserClient访问：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer"</span>)</span><br><span class="line"><span class="meta">@Slf</span>4j</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserClient userClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userClient.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="1-2-3-开启Feign功能"><a href="#1-2-3-开启Feign功能" class="headerlink" title="1.2.3.开启Feign功能"></a>1.2.3.开启Feign功能</h3><p>我们在启动类上，添加注解，开启Feign功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="meta">@EnableFeignClients</span> <span class="comment">// 开启Feign功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerDemoApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserConsumerDemoApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>你会发现RestTemplate的注册被我删除了。Feign中已经自动集成了Ribbon负载均衡，因此我们不需要自己定义RestTemplate了</li></ul><h3 id="1-2-4-启动测试："><a href="#1-2-4-启动测试：" class="headerlink" title="1.2.4.启动测试："></a>1.2.4.启动测试：</h3><p>访问接口：</p><p> <img src="\blogPic\springcloud2\1533907548664.png" alt="1533907548664"></p><p>正常获取到了结果。</p><h2 id="1-3-负载均衡"><a href="#1-3-负载均衡" class="headerlink" title="1.3.负载均衡"></a>1.3.负载均衡</h2><p>Feign中本身已经集成了Ribbon依赖和自动配置：</p><p>​    <img src="\blogPic\springcloud2\1525672070679.png" alt="1525672070679"></p><p>因此我们不需要额外引入依赖，也不需要再注册<code>RestTemplate</code>对象。</p><h2 id="1-4-Hystix支持"><a href="#1-4-Hystix支持" class="headerlink" title="1.4.Hystix支持"></a>1.4.Hystix支持</h2><p>Feign默认也有对Hystix的集成：</p><p>​    <img src="\blogPic\springcloud2\1525672466192.png" alt="1525672466192"></p><p>只不过，默认情况下是关闭的。我们需要通过下面的参数来开启：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  hystrix:</span></span><br><span class="line"><span class="attr">    enabled:</span> <span class="literal">true</span> <span class="comment"># 开启Feign的熔断功能</span></span><br></pre></td></tr></table></figure><p>但是，Feign中的Fallback配置不像Ribbon中那样简单了。</p><p>1）首先，我们要定义一个类，实现刚才编写的UserFeignClient，作为fallback的处理类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserClientFallback</span> <span class="keyword">implements</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">new</span> User();</span><br><span class="line">        user.setId(id);</span><br><span class="line">        user.setName(<span class="string">"用户查询出现异常！"</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>2）然后在UserFeignClient中，指定刚才编写的实现类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"user-service"</span>, fallback = UserFeignClientFallback.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）重启测试：</p><p>我们关闭user-service服务，然后在页面访问：</p><p> <img src="\blogPic\springcloud2\1533942286259.png" alt="1533942286259"></p><h2 id="1-5-请求压缩-了解"><a href="#1-5-请求压缩-了解" class="headerlink" title="1.5.请求压缩(了解)"></a>1.5.请求压缩(了解)</h2><p>Spring Cloud Feign 支持对请求和响应进行GZIP压缩，以减少通信过程中的性能损耗。通过下面的参数即可开启请求与响应的压缩功能：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line"><span class="attr">    response:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 开启响应压缩</span></span><br></pre></td></tr></table></figure><p>同时，我们也可以对请求的数据类型，以及触发压缩的大小下限进行设置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">feign:</span></span><br><span class="line"><span class="attr">  compression:</span></span><br><span class="line"><span class="attr">    request:</span></span><br><span class="line"><span class="attr">      enabled:</span> <span class="literal">true</span> <span class="comment"># 开启请求压缩</span></span><br><span class="line"><span class="attr">      mime-types:</span> <span class="string">text/html,application/xml,application/json</span> <span class="comment"># 设置压缩的数据类型</span></span><br><span class="line"><span class="attr">      min-request-size:</span> <span class="number">2048</span> <span class="comment"># 设置触发压缩的大小下限</span></span><br></pre></td></tr></table></figure><p>注：上面的数据类型、压缩大小下限均为默认值。</p><h2 id="1-6-日志级别-了解"><a href="#1-6-日志级别-了解" class="headerlink" title="1.6.日志级别(了解)"></a>1.6.日志级别(了解)</h2><p>前面讲过，通过<code>logging.level.xx=debug</code>来设置日志级别。然而这个对Fegin客户端而言不会产生效果。因为<code>@FeignClient</code>注解修改的客户端在被代理时，都会创建一个新的Fegin.Logger实例。我们需要额外指定这个日志的级别才可以。</p><p>1）设置cn.itcast包下的日志级别都为debug</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">logging:</span></span><br><span class="line"><span class="attr">  level:</span></span><br><span class="line">    <span class="string">cn.itcast:</span> <span class="string">debug</span></span><br></pre></td></tr></table></figure><p>2）编写配置类，定义日志级别</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">FeignConfig</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    Logger.<span class="function">Level <span class="title">feignLoggerLevel</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> Logger.Level.FULL;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这里指定的Level级别是FULL，Feign支持4种级别：</p><p>​    <img src="\blogPic\springcloud2\1525674373507.png" alt="1525674373507"></p><ul><li>NONE：不记录任何日志信息，这是默认值。</li><li>BASIC：仅记录请求的方法，URL以及响应状态码和执行时间</li><li>HEADERS：在BASIC的基础上，额外记录了请求和响应的头信息</li><li>FULL：记录所有请求和响应的明细，包括头信息、请求体、元数据。</li></ul><p>3）在FeignClient中指定配置类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@FeignClient</span>(value = <span class="string">"user-service"</span>, fallback = UserClientFallback.class, configuration = FeignConfig.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserClient</span> </span>&#123;</span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/user/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function">User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>4）重启项目，即可看到每次访问的日志：</p><p><img src="\blogPic\springcloud2\1525674544569.png" alt="1525674544569"></p><h1 id="2-Zuul网关"><a href="#2-Zuul网关" class="headerlink" title="2.Zuul网关"></a>2.Zuul网关</h1><h2 id="2-1-简介"><a href="#2-1-简介" class="headerlink" title="2.1.简介"></a>2.1.简介</h2><p>官网：<a href="https://github.com/Netflix/zuul" target="_blank" rel="noopener">https://github.com/Netflix/zuul</a></p><p>​    <img src="\blogPic\springcloud2\1525675037152.png" alt="1525675037152"></p><p>Zuul：维基百科：</p><p>电影《捉鬼敢死队》中的怪兽，Zuul，在纽约引发了巨大骚乱。</p><p>事实上，在微服务架构中，Zuul就是守门的大Boss！一夫当关，万夫莫开！</p><p><img src="\blogPic\springcloud2\1525675168152.png" alt="1525675168152"></p><p>网关的核心功能是：过滤和路由</p><h2 id="2-2-Zuul加入后的架构"><a href="#2-2-Zuul加入后的架构" class="headerlink" title="2.2.Zuul加入后的架构"></a>2.2.Zuul加入后的架构</h2><p><img src="\blogPic\springcloud2\1525675648881.png" alt="1525675648881"></p><ul><li>不管是来自于客户端（PC或移动端）的请求，还是服务内部调用。一切对服务的请求都会经过Zuul这个网关，然后再由网关来实现 鉴权、动态路由等等操作。Zuul就是我们服务的统一入口。</li></ul><h2 id="2-3-快速入门"><a href="#2-3-快速入门" class="headerlink" title="2.3.快速入门"></a>2.3.快速入门</h2><h3 id="2-3-1-新建工程"><a href="#2-3-1-新建工程" class="headerlink" title="2.3.1.新建工程"></a>2.3.1.新建工程</h3><p>填写基本信息：</p><p><img src="\blogPic\springcloud2\1529223147899.png" alt="1529223147899"></p><p>添加Zuul依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w2.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>zuul-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-zuul<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-3-2-编写启动类"><a href="#2-3-2-编写启动类" class="headerlink" title="2.3.2.编写启动类"></a>2.3.2.编写启动类</h3><p>通过<code>@EnableZuulProxy</code>注解开启Zuul的功能：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-3-2-编写配置"><a href="#2-3-2-编写配置" class="headerlink" title="2.3.2.编写配置"></a>2.3.2.编写配置</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10010</span> <span class="comment">#服务端口</span></span><br><span class="line"><span class="attr">spring:</span> </span><br><span class="line"><span class="attr">  application:</span>  </span><br><span class="line"><span class="attr">    name:</span> <span class="string">api-gateway</span> <span class="comment">#指定服务名</span></span><br></pre></td></tr></table></figure><h3 id="2-3-4-编写路由规则"><a href="#2-3-4-编写路由规则" class="headerlink" title="2.3.4.编写路由规则"></a>2.3.4.编写路由规则</h3><p>我们需要用Zuul来代理user-service服务，先看一下控制面板中的服务状态：</p><p><img src="\blogPic\springcloud2\1525676797879.png" alt="1525676797879"></p><ul><li>ip为：127.0.0.1</li><li>端口为：8081</li></ul><p>映射规则：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    user-service:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line"><span class="attr">      url:</span> <span class="attr">http://127.0.0.1:8081</span> <span class="comment"># 映射路径对应的实际url地址</span></span><br></pre></td></tr></table></figure><p>我们将符合<code>path</code> 规则的一切请求，都代理到 <code>url</code>参数指定的地址</p><p>本例中，我们将 <code>/user-service/**</code>开头的请求，代理到<a href="http://127.0.0.1:8081" target="_blank" rel="noopener">http://127.0.0.1:8081</a></p><h3 id="2-3-5-启动测试："><a href="#2-3-5-启动测试：" class="headerlink" title="2.3.5.启动测试："></a>2.3.5.启动测试：</h3><p>访问的路径中需要加上配置规则的映射路径，我们访问：<a href="http://127.0.0.1:8081/user-service/user/10" target="_blank" rel="noopener">http://127.0.0.1:8081/user-service/user/10</a></p><p>​    <img src="\blogPic\springcloud2\1525677046705.png" alt="1525677046705"></p><h2 id="2-4-面向服务的路由"><a href="#2-4-面向服务的路由" class="headerlink" title="2.4.面向服务的路由"></a>2.4.面向服务的路由</h2><p>在刚才的路由规则中，我们把路径对应的服务地址写死了！如果同一服务有多个实例的话，这样做显然就不合理了。</p><p>我们应该根据服务的名称，去Eureka注册中心查找 服务对应的所有实例列表，然后进行动态路由才对！</p><h3 id="2-4-1-添加Eureka客户端依赖"><a href="#2-4-1-添加Eureka客户端依赖" class="headerlink" title="2.4.1.添加Eureka客户端依赖"></a>2.4.1.添加Eureka客户端依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-4-2-开启Eureka客户端发现功能"><a href="#2-4-2-开启Eureka客户端发现功能" class="headerlink" title="2.4.2.开启Eureka客户端发现功能"></a>2.4.2.开启Eureka客户端发现功能</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableZuulProxy</span> <span class="comment">// 开启Zuul的网关功能</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ZuulApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(ZuulApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-4-3-添加Eureka配置，获取服务信息"><a href="#2-4-3-添加Eureka配置，获取服务信息" class="headerlink" title="2.4.3.添加Eureka配置，获取服务信息"></a>2.4.3.添加Eureka配置，获取服务信息</h3><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    prefer-ip-address:</span> <span class="literal">true</span></span><br><span class="line"><span class="attr">    ip-address:</span> <span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span></span><br></pre></td></tr></table></figure><h3 id="2-4-4-修改映射配置，通过服务名称获取"><a href="#2-4-4-修改映射配置，通过服务名称获取" class="headerlink" title="2.4.4.修改映射配置，通过服务名称获取"></a>2.4.4.修改映射配置，通过服务名称获取</h3><p>因为已经有了Eureka客户端，我们可以从Eureka获取服务的地址信息，因此映射时无需指定IP地址，而是通过服务名称来访问，而且Zuul已经集成了Ribbon的负载均衡功能。</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    user-service:</span> <span class="comment"># 这里是路由id，随意写</span></span><br><span class="line"><span class="attr">      path:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br><span class="line"><span class="attr">      serviceId:</span> <span class="string">user-service</span> <span class="comment"># 指定服务名称</span></span><br></pre></td></tr></table></figure><h3 id="2-4-5-启动测试"><a href="#2-4-5-启动测试" class="headerlink" title="2.4.5.启动测试"></a>2.4.5.启动测试</h3><p>再次启动，这次Zuul进行代理时，会利用Ribbon进行负载均衡访问：</p><p>​    <img src="\blogPic\springcloud2\1525677821212.png" alt="1525677821212"></p><p>日志中可以看到使用了负载均衡器：</p><p><img src="\blogPic\springcloud2\1525677891119.png" alt="1525677891119"></p><h2 id="2-5-简化的路由配置"><a href="#2-5-简化的路由配置" class="headerlink" title="2.5.简化的路由配置"></a>2.5.简化的路由配置</h2><p>在刚才的配置中，我们的规则是这样的：</p><ul><li><code>zuul.routes.&lt;route&gt;.path=/xxx/**</code>： 来指定映射路径。<code>&lt;route&gt;</code>是自定义的路由名</li><li><code>zuul.routes.&lt;route&gt;.serviceId=/user-service</code>：来指定服务名。</li></ul><p>而大多数情况下，我们的<code>&lt;route&gt;</code>路由名称往往和 服务名会写成一样的。因此Zuul就提供了一种简化的配置语法：<code>zuul.routes.&lt;serviceId&gt;=&lt;path&gt;</code></p><p>比方说上面我们关于user-service的配置可以简化为一条：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    user-service:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br></pre></td></tr></table></figure><p>省去了对服务名称的配置。</p><h2 id="2-6-默认的路由规则"><a href="#2-6-默认的路由规则" class="headerlink" title="2.6.默认的路由规则"></a>2.6.默认的路由规则</h2><p>在使用Zuul的过程中，上面讲述的规则已经大大的简化了配置项。但是当服务较多时，配置也是比较繁琐的。因此Zuul就指定了默认的路由规则：</p><ul><li>默认情况下，一切服务的映射路径就是服务名本身。<ul><li>例如服务名为：<code>user-service</code>，则默认的映射路径就是：<code>/user-service/**</code></li></ul></li></ul><p>也就是说，刚才的映射规则我们完全不配置也是OK的，不信就试试看。</p><p>如果想要禁用某个路由规则，可以这样：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  ignored-services:</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">user-service</span></span><br><span class="line"><span class="bullet">    -</span> <span class="string">consumer</span></span><br></pre></td></tr></table></figure><h2 id="2-7-路由前缀"><a href="#2-7-路由前缀" class="headerlink" title="2.7.路由前缀"></a>2.7.路由前缀</h2><p>配置示例：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">zuul:</span></span><br><span class="line"><span class="attr">  prefix:</span> <span class="string">/api</span> <span class="comment"># 添加路由前缀</span></span><br><span class="line"><span class="attr">  routes:</span></span><br><span class="line"><span class="attr">    user-service:</span> <span class="string">/user-service/**</span> <span class="comment"># 这里是映射路径</span></span><br></pre></td></tr></table></figure><p>我们通过<code>zuul.prefix=/api</code>来指定了路由的前缀，这样在发起请求时，路径就要以/api开头。</p><p>路径<code>/api/user-service/user/1</code>将会被代理到<code>/user-service/user/1</code></p><h2 id="2-8-过滤器"><a href="#2-8-过滤器" class="headerlink" title="2.8.过滤器"></a>2.8.过滤器</h2><p>Zuul作为网关的其中一个重要功能，就是实现请求的鉴权。而这个动作我们往往是通过Zuul提供的过滤器来实现的。</p><h3 id="2-8-1-ZuulFilter"><a href="#2-8-1-ZuulFilter" class="headerlink" title="2.8.1.ZuulFilter"></a>2.8.1.ZuulFilter</h3><p>ZuulFilter是过滤器的顶级父类。在这里我们看一下其中定义的4个最重要的方法：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> ZuulFilter implements IZuulFilter&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span></span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">abstract</span> <span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span></span>;</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span></span>;<span class="comment">// 来自IZuulFilter</span></span><br><span class="line"></span><br><span class="line">    <span class="function">Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException</span>;<span class="comment">// IZuulFilter</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><code>shouldFilter</code>：返回一个<code>Boolean</code>值，判断该过滤器是否需要执行。返回true执行，返回false不执行。</li><li><code>run</code>：过滤器的具体业务逻辑。</li><li><code>filterType</code>：返回字符串，代表过滤器的类型。包含以下4种：<ul><li><code>pre</code>：请求在被路由之前执行</li><li><code>routing</code>：在路由请求时调用</li><li><code>post</code>：在routing和errror过滤器之后调用</li><li><code>error</code>：处理请求时发生错误调用</li></ul></li><li><code>filterOrder</code>：通过返回的int值来定义过滤器的执行顺序，数字越小优先级越高。</li></ul><h3 id="2-8-2-过滤器执行生命周期："><a href="#2-8-2-过滤器执行生命周期：" class="headerlink" title="2.8.2.过滤器执行生命周期："></a>2.8.2.过滤器执行生命周期：</h3><p>这张是Zuul官网提供的请求生命周期图，清晰的表现了一次请求在各个过滤器的执行顺序。</p><p><img src="\blogPic\springcloud2\1533945001048.png" alt="1533945001048"></p><ul><li>正常流程：<ul><li>请求到达首先会经过pre类型过滤器，而后到达routing类型，进行路由，请求就到达真正的服务提供者，执行请求，返回结果后，会到达post过滤器。而后返回响应。</li></ul></li><li>异常流程：<ul><li>整个过程中，pre或者routing过滤器出现异常，都会直接进入error过滤器，再error处理完毕后，会将请求交给POST过滤器，最后返回给用户。</li><li>如果是error过滤器自己出现异常，最终也会进入POST过滤器，而后返回。</li><li>如果是POST过滤器出现异常，会跳转到error过滤器，但是与pre和routing不同的时，请求不会再到达POST过滤器了。</li></ul></li></ul><p>所有内置过滤器列表：</p><p>​    <img src="\blogPic\springcloud2\1525682427811.png" alt="1525682427811"></p><h3 id="2-8-3-使用场景"><a href="#2-8-3-使用场景" class="headerlink" title="2.8.3.使用场景"></a>2.8.3.使用场景</h3><p>场景非常多：</p><ul><li>请求鉴权：一般放在pre类型，如果发现没有访问权限，直接就拦截了</li><li>异常处理：一般会在error类型和post类型过滤器中结合来处理。</li><li>服务调用时长统计：pre和post结合使用。</li></ul><h2 id="2-9-自定义过滤器"><a href="#2-9-自定义过滤器" class="headerlink" title="2.9.自定义过滤器"></a>2.9.自定义过滤器</h2><p>接下来我们来自定义一个过滤器，模拟一个登录的校验。基本逻辑：如果请求中有access-token参数，则认为请求有效，放行。</p><h3 id="2-9-1-定义过滤器类"><a href="#2-9-1-定义过滤器类" class="headerlink" title="2.9.1.定义过滤器类"></a>2.9.1.定义过滤器类</h3><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Component</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginFilter</span> <span class="keyword">extends</span> <span class="title">ZuulFilter</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">filterType</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_TYPE;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">filterOrder</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> FilterConstants.PRE_DECORATION_FILTER_ORDER - <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">shouldFilter</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> Object <span class="title">run</span><span class="params">()</span> <span class="keyword">throws</span> ZuulException </span>&#123;</span><br><span class="line">        <span class="comment">// 获取请求上下文</span></span><br><span class="line">        RequestContext ctx = RequestContext.getCurrentContext();</span><br><span class="line">        <span class="comment">// 获取request对象</span></span><br><span class="line">        HttpServletRequest request = ctx.getRequest();</span><br><span class="line">        <span class="comment">// 获取请求参数</span></span><br><span class="line">        String token = request.getParameter(<span class="string">"access-token"</span>);</span><br><span class="line">        <span class="comment">// 判断是否存在</span></span><br><span class="line">        <span class="keyword">if</span>(StringUtils.isBlank(token))&#123;</span><br><span class="line">            <span class="comment">// 不存在，未登录，拦截</span></span><br><span class="line">            ctx.setSendZuulResponse(<span class="keyword">false</span>);</span><br><span class="line">            <span class="comment">// 设置返回状态码</span></span><br><span class="line">            ctx.setResponseStatusCode(HttpStatus.UNAUTHORIZED.value());</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">null</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="2-9-2-测试"><a href="#2-9-2-测试" class="headerlink" title="2.9.2.测试"></a>2.9.2.测试</h3><p>没有token参数时，访问失败：</p><p>​    <img src="\blogPic\springcloud2\1525683285697.png" alt="1525683285697"></p><p>添加token参数后：</p><p>​    <img src="\blogPic\springcloud2\1525683354113.png" alt="1525683354113"></p><h2 id="2-10-负载均衡和熔断"><a href="#2-10-负载均衡和熔断" class="headerlink" title="2.10.负载均衡和熔断"></a>2.10.负载均衡和熔断</h2><p>Zuul中默认就已经集成了Ribbon负载均衡和Hystix熔断机制。但是所有的超时策略都是走的默认值，比如熔断超时时间只有1S，很容易就触发了。因此建议我们手动进行配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">6000</span></span><br></pre></td></tr></table></figure><h2 id="2-11-Zuul的高可用"><a href="#2-11-Zuul的高可用" class="headerlink" title="2.11.Zuul的高可用"></a>2.11.Zuul的高可用</h2><p>启动多个Zuul服务，自动注册到Eureka，形成集群。如果是服务内部访问，你访问Zuul，自动负载均衡，没问题。</p><p>但是，Zuul更多是外部访问，PC端、移动端等。他们无法通过Eureka进行负载均衡，那么该怎么办？</p><p>此时，我们会使用其它的服务网关，来对Zuul进行代理。比如：Nginx</p><p>Eureka、Ribbon、Hystix、Feign、Zuul</p><p>spring-cloud-config：统一配置中心，自动去Git拉取最新的配置，缓存。使用Git的Webhook钩子，去通知配置中心，说配置发生了变化，配置中心会通过消息总线去通知所有的微服务，更新配置。</p><p>spring-cloud-bus：消息总线</p><p>Spring-cloud-stream：消息通信</p><p>spring-cloud-hystrix-dashboard：容错统计，形成图形化界面</p><p>spring-cloud-sleuth：链路追踪 结合Zipkin</p><h1 id="3-ES6-语法指南"><a href="#3-ES6-语法指南" class="headerlink" title="3.ES6 语法指南"></a>3.ES6 语法指南</h1><p>后端项目搭建完毕，接下来就是前端页面了。不过在这之前需要一些准备工作。我们需要学习ES6的语法标准。</p><p>什么是ES6？就是ECMAScript第6版标准。</p><h2 id="3-1-什么是ECMAScript？"><a href="#3-1-什么是ECMAScript？" class="headerlink" title="3.1.什么是ECMAScript？"></a>3.1.什么是ECMAScript？</h2><p>来看下前端的发展历程：</p><blockquote><p>web1.0时代：</p></blockquote><ul><li>最初的网页以HTML为主，是纯静态的网页。网页是只读的，信息流只能从服务的到客户端单向流通。<strong>开发人员也只关心页面的样式和内容</strong>即可。</li></ul><blockquote><p>web2.0时代：</p></blockquote><ul><li>1995年，网景工程师Brendan Eich 花了10天时间设计了JavaScript语言。</li><li>1996年，微软发布了JScript，其实是JavaScript的逆向工程实现。</li><li>1997年，为了统一各种不同script脚本语言，ECMA（欧洲计算机制造商协会）以JavaScript为基础，制定了<code>ECMAscript</code>标准规范。JavaScript和JScript都是<code>ECMAScript</code>的标准实现者，随后各大浏览器厂商纷纷实现了<code>ECMAScript</code>标准。</li></ul><p>所以，ECMAScript是浏览器脚本语言的规范，而各种我们熟知的js语言，如JavaScript则是规范的具体实现。</p><h2 id="3-2-ECMAScript的快速发展"><a href="#3-2-ECMAScript的快速发展" class="headerlink" title="3.2.ECMAScript的快速发展"></a>3.2.ECMAScript的快速发展</h2><p>而后，ECMAScript就进入了快速发展期。</p><ul><li><p>1998年6月，ECMAScript 2.0 发布。</p></li><li><p>1999年12月，ECMAScript 3.0 发布。这时，ECMAScript 规范本身也相对比较完善和稳定了，但是接下来的事情，就比较悲剧了。</p></li><li><p>2007年10月。。。。ECMAScript 4.0 草案发布。</p><p>这次的新规范，历时颇久，规范的新内容也有了很多争议。在制定ES4的时候，是分成了两个工作组同时工作的。</p><ul><li>一边是以 Adobe, Mozilla, Opera 和 Google为主的 ECMAScript 4 工作组。</li><li>一边是以 Microsoft 和 Yahoo 为主的 ECMAScript 3.1 工作组。</li></ul><p>ECMAScript 4 的很多主张比较激进，改动较大。而 ECMAScript 3.1 则主张小幅更新。最终经过 TC39 的会议，决定将一部分不那么激进的改动保留发布为 ECMAScript 3.1，而ES4的内容，则延续到了后来的ECMAScript5和6版本中</p></li><li><p>2009年12月，ECMAScript 5 发布。</p></li><li><p>2011年6月，ECMAScript 5.1 发布。</p></li><li><p>2015年6月，ECMAScript 6，也就是 ECMAScript 2015 发布了。 并且从 ECMAScript 6 开始，开始采用年号来做版本。即 ECMAScript 2015，就是ECMAScript6。 </p></li></ul><h2 id="3-3-ES5和6的一些新特性"><a href="#3-3-ES5和6的一些新特性" class="headerlink" title="3.3.ES5和6的一些新特性"></a>3.3.ES5和6的一些新特性</h2><p>我们这里只把一些常用的进行学习，更详细的大家参考：<a href="http://es6.ruanyifeng.com/?search=reduce&amp;x=0&amp;y=0#README" target="_blank" rel="noopener">阮一峰的ES6教程</a></p><h3 id="3-3-1-let-和-const-命令"><a href="#3-3-1-let-和-const-命令" class="headerlink" title="3.3.1.let 和 const 命令"></a>3.3.1.let 和 const 命令</h3><blockquote><p>var</p></blockquote><p>之前，js定义变量只有一个关键字：<code>var</code></p><p><code>var</code>有一个问题，就是定义的变量有时会莫名奇妙的成为全局变量。</p><p>例如这样的一段代码：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"循环外："</span> + i)</span><br></pre></td></tr></table></figure><p>你猜下打印的结果是什么？</p><p> <img src="\blogPic\springcloud2\1526107278999.png" alt="1526107278999"></p><blockquote><p>let</p></blockquote><p><code>let</code>所声明的变量，只在<code>let</code>命令所在的代码块内有效。</p><p>我们把刚才的<code>var</code>改成<code>let</code>试试：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">"循环外："</span> + i)</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="\blogPic\springcloud2\1526107347275.png" alt="1526107347275"></p><blockquote><p>const</p></blockquote><p><code>const</code>声明的变量是常量，不能被修改</p><p> <img src="\blogPic\springcloud2\1526107425000.png" alt="1526107425000"></p><h3 id="3-3-2-解构表达式"><a href="#3-3-2-解构表达式" class="headerlink" title="3.3.2.解构表达式"></a>3.3.2.解构表达式</h3><blockquote><p>数组解构</p></blockquote><p>比如有一个数组：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]</span><br></pre></td></tr></table></figure><p>我想获取其中的值，只能通过角标。ES6可以这样：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> [x,y,z] = arr;<span class="comment">// x，y，z将与arr中的每个位置对应来取值</span></span><br><span class="line"><span class="comment">// 然后打印</span></span><br><span class="line"><span class="built_in">console</span>.log(x,y,z);</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="\blogPic\springcloud2\1526109778368.png" alt="1526109778368"></p><blockquote><p>对象解构</p></blockquote><p>例如有个person对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">'java'</span>,<span class="string">'js'</span>,<span class="string">'css'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们可以这么做：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 解构表达式获取值</span></span><br><span class="line"><span class="keyword">const</span> &#123;name,age,language&#125; = person;</span><br><span class="line"><span class="comment">// 打印</span></span><br><span class="line"><span class="built_in">console</span>.log(name);</span><br><span class="line"><span class="built_in">console</span>.log(age);</span><br><span class="line"><span class="built_in">console</span>.log(language);</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="\blogPic\springcloud2\1526109984544.png" alt="1526109984544"></p><p>如过想要用其它变量接收，需要额外指定别名：</p><p> <img src="\blogPic\springcloud2\1526110159450.png" alt="1526110159450"></p><ul><li><code>{name:n}</code>：name是person中的属性名，冒号后面的n是解构后要赋值给的变量。</li></ul><blockquote><p>解构表达式拷贝对象属性：</p></blockquote><p>比如我们有一个person对象：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">'java'</span>,<span class="string">'js'</span>,<span class="string">'css'</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我想获取它的<code>name</code>和<code>age</code>属性，封装到新的对象，该怎么办？</p><p> <img src="\blogPic\springcloud2\1533943817175.png" alt="1533943817175"></p><p>我们在解构表达式中，通过<code>language</code>接收到语言，剩下的所有属性用 <code>... obj</code>方式，可以一起接收，这样<code>obj</code>就是一个新的对象，包含了<code>person</code>中，除了<code>language</code>外的所有其它属性</p><p>数组也可以采用类似操作。</p><h3 id="3-3-4-函数优化"><a href="#3-3-4-函数优化" class="headerlink" title="3.3.4.函数优化"></a>3.3.4.函数优化</h3><blockquote><p>箭头函数</p></blockquote><p>ES6中定义函数的简写方式：</p><p>一个参数时：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> print = <span class="function"><span class="keyword">function</span> (<span class="params">obj</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> print2 = <span class="function"><span class="params">obj</span> =&gt;</span> <span class="built_in">console</span>.log(obj);</span><br></pre></td></tr></table></figure><p>多个参数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 两个参数的情况：</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span> (<span class="params">a , b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 简写为：</span></span><br><span class="line"><span class="keyword">var</span> sum2 = <span class="function">(<span class="params">a,b</span>) =&gt;</span> a+b;</span><br></pre></td></tr></table></figure><p>代码不止一行，可以用<code>{}</code>括起来</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sum3 = <span class="function">(<span class="params">a,b</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>对象的函数属性简写</p></blockquote><p>比如一个Person对象，里面有eat方法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> person = &#123;</span><br><span class="line">    name: <span class="string">"jack"</span>,</span><br><span class="line">    <span class="comment">// 以前：</span></span><br><span class="line">    eat: <span class="function"><span class="keyword">function</span> (<span class="params">food</span>) </span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在吃"</span> + food);</span><br><span class="line">    &#125;,</span><br><span class="line">    <span class="comment">// 箭头函数版：</span></span><br><span class="line">    eat2: <span class="function"><span class="params">food</span> =&gt;</span> <span class="built_in">console</span>.log(person.name + <span class="string">"在吃"</span> + food),<span class="comment">// 这里拿不到this</span></span><br><span class="line">    <span class="comment">// 简写版：</span></span><br><span class="line">    eat3(food)&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="keyword">this</span>.name + <span class="string">"在吃"</span> + food);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>箭头函数结合解构表达式</p></blockquote><p>比如有一个函数：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">    name:<span class="string">"jack"</span>,</span><br><span class="line">    age:<span class="number">21</span>,</span><br><span class="line">    language: [<span class="string">'java'</span>,<span class="string">'js'</span>,<span class="string">'css'</span>]</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hello</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">"hello,"</span> + person.name)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>如果用箭头函数和解构表达式</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> hi = <span class="function">(<span class="params">&#123;name&#125;</span>) =&gt;</span>  <span class="built_in">console</span>.log(<span class="string">"hello,"</span> + name);</span><br></pre></td></tr></table></figure><h3 id="3-3-5-map和reduce"><a href="#3-3-5-map和reduce" class="headerlink" title="3.3.5.map和reduce"></a>3.3.5.map和reduce</h3><p>数组中新增了map和reduce方法。</p><blockquote><p>map</p></blockquote><p><code>map()</code>：接收一个函数，将原数组中的所有元素用这个函数处理后放入新数组返回。</p><p>举例：有一个字符串数组，我们希望转为int数组</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [<span class="string">'1'</span>,<span class="string">'20'</span>,<span class="string">'-5'</span>,<span class="string">'3'</span>];</span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br><span class="line"></span><br><span class="line">arr = arr.map(<span class="function"><span class="params">s</span> =&gt;</span> <span class="built_in">parseInt</span>(s));</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(arr)</span><br></pre></td></tr></table></figure><p>  <img src="\blogPic\springcloud2\1526110796839.png" alt="1526110796839"></p><blockquote><p>reduce</p></blockquote><p><code>reduce()</code>：接收一个函数（必须）和一个初始值（可选），该函数接收两个参数：</p><ul><li>第一个参数是上一次reduce处理的结果</li><li>第二个参数是数组中要处理的下一个元素</li></ul><p><code>reduce()</code>会从左到右依次把数组中的元素用reduce处理，并把处理的结果作为下次reduce的第一个参数。如果是第一次，会把前两个元素作为计算参数，或者把用户指定的初始值作为起始参数</p><p>举例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const arr = [1,20,-5,3]</span><br></pre></td></tr></table></figure><p>没有初始值：</p><p> <img src="\blogPic\springcloud2\1526111537204.png" alt="1526111537204"></p><p>指定初始值：</p><p> <img src="\blogPic\springcloud2\1526111580742.png" alt="1526111580742"></p><h3 id="3-3-6-promise"><a href="#3-3-6-promise" class="headerlink" title="3.3.6.promise"></a>3.3.6.promise</h3><p>所谓Promise，简单说就是一个容器，里面保存着某个未来才会结束的事件（通常是一个异步操作）的结果。从语法上说，Promise 是一个对象，从它可以获取异步操作的消息。Promise 提供统一的 API，各种异步操作都可以用同样的方法进行处理。</p><p>感觉跟java的Future类很像啊，有木有！</p><p>我们可以通过Promise的构造函数来创建Promise对象，并在内部封装一个异步执行的结果。</p><p>语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ... 执行异步操作</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="comment">/* 异步操作成功 */</span>)&#123;</span><br><span class="line">    resolve(value);<span class="comment">// 调用resolve，代表Promise将返回成功的结果</span></span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    reject(error);<span class="comment">// 调用reject，代表Promise会返回失败结果</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>这样，在promise中就封装了一段异步执行的结果。</p><p>如果我们想要等待异步执行完成，做一些事情，我们可以通过promise的then方法来实现,语法：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行成功后的回调</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure><p>如果想要处理promise异步执行失败的事件，还可以跟上catch：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行成功后的回调</span></span><br><span class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</span><br><span class="line">    <span class="comment">// 异步执行失败后的回调</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>示例：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">const p = new Promise(function (resolve, reject) &#123;</span><br><span class="line">    // 这里我们用定时任务模拟异步</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">        const num = Math.random();</span><br><span class="line">        // 随机返回成功或失败</span><br><span class="line">        if (num &lt; 0.5) &#123;</span><br><span class="line">            resolve(&quot;成功！num:&quot; + num)</span><br><span class="line">        &#125; else &#123;</span><br><span class="line">            reject(&quot;出错了！num:&quot; + num)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;, 300)</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">// 调用promise</span><br><span class="line">p.then(function (msg) &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">&#125;).catch(function (msg) &#123;</span><br><span class="line">    console.log(msg);</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="\blogPic\springcloud2\1526113115887.png" alt="1526113115887"></p><p> <img src="\blogPic\springcloud2\1526113140074.png" alt="1526113140074"></p><h3 id="3-3-7-对象扩展"><a href="#3-3-7-对象扩展" class="headerlink" title="3.3.7.对象扩展"></a>3.3.7.对象扩展</h3><p>ES6给Object拓展了许多新的方法，如：</p><ul><li>keys(obj)：获取对象的所有key形成的数组</li><li>values(obj)：获取对象的所有value形成的数组</li><li>entries(obj)：获取对象的所有key和value形成的二维数组。格式：<code>[[k1,v1],[k2,v2],...]</code></li><li><p>assian(dest, …src) ：将多个src对象的值 拷贝到 dest中（浅拷贝）。</p><p><img src="\blogPic\springcloud2\1527210872966.png" alt="1527210872966"></p></li></ul><h3 id="3-3-8-数组扩展"><a href="#3-3-8-数组扩展" class="headerlink" title="3.3.8.数组扩展"></a>3.3.8.数组扩展</h3><p>ES6给数组新增了许多方法：</p><ul><li>find(callback)：把数组中的元素逐个传递给函数callback执行，如果返回true，则返回该元素</li><li>findIndex(callback)：与find类似，不过返回的是品牌到的元素的索引</li><li><p>includes（element）：判断指定元素是否存在</p><p><img src="\blogPic\springcloud2\1533944220125.png" alt="1533944220125"></p></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringCloud基础学习-续&quot;&gt;&lt;a href=&quot;#SpringCloud基础学习-续&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud基础学习(续)&quot;&gt;&lt;/a&gt;SpringCloud基础学习(续)&lt;/h1&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>springboot</title>
    <link href="http://yoursite.com/2019/01/17/springboot/"/>
    <id>http://yoursite.com/2019/01/17/springboot/</id>
    <published>2019-01-17T06:33:33.000Z</published>
    <updated>2019-01-17T06:43:59.711Z</updated>
    
    <content type="html"><![CDATA[<h1 id="这是Springboot的相关学习"><a href="#这是Springboot的相关学习" class="headerlink" title="这是Springboot的相关学习"></a>这是Springboot的相关学习</h1><a id="more"></a><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解SpringBoot的作用</li><li>掌握java配置的方式</li><li>了解SpringBoot自动配置原理</li><li>掌握SpringBoot的基本使用</li><li>了解Thymeleaf的基本使用</li></ul><h1 id="1-了解SpringBoot"><a href="#1-了解SpringBoot" class="headerlink" title="1. 了解SpringBoot"></a>1. 了解SpringBoot</h1><p>在这一部分，我们主要了解以下3个问题：</p><ul><li>什么是SpringBoot</li><li>为什么要学习SpringBoot</li><li>SpringBoot的特点</li></ul><h2 id="1-1-什么是SpringBoot"><a href="#1-1-什么是SpringBoot" class="headerlink" title="1.1.什么是SpringBoot"></a>1.1.什么是SpringBoot</h2><p>SpringBoot是Spring项目中的一个子工程，与我们所熟知的Spring-framework 同属于spring的产品:</p><p><img src="\blogPic\springboot\1525484756737.png" alt="1525484756737"></p><p>我们可以看到下面的一段介绍：</p><blockquote><p>Takes an opinionated view of building production-ready Spring applications. Spring Boot favors convention over configuration and is designed to get you up and running as quickly as possible.</p></blockquote><p>翻译一下：</p><blockquote><p>用一些固定的方式来构建生产级别的spring应用。Spring Boot 推崇约定大于配置的方式以便于你能够尽可能快速的启动并运行程序。</p></blockquote><p>其实人们把Spring Boot 称为搭建程序的<code>脚手架</code>。其最主要作用就是帮我们快速的构建庞大的spring项目，并且尽可能的减少一切xml配置，做到开箱即用，迅速上手，让我们关注与业务而非配置。</p><h2 id="1-2-为什么要学习SpringBoot"><a href="#1-2-为什么要学习SpringBoot" class="headerlink" title="1.2.为什么要学习SpringBoot"></a>1.2.为什么要学习SpringBoot</h2><p>java一直被人诟病的一点就是臃肿、麻烦。当我们还在辛苦的搭建项目时，可能Python程序员已经把功能写好了，究其原因注意是两点：</p><ul><li><p>复杂的配置，</p><p>项目各种配置其实是开发时的损耗， 因为在思考 Spring 特性配置和解决业务问题之间需要进行思维切换，所以写配置挤占了写应用程序逻辑的时间。</p></li><li><p>一个是混乱的依赖管理。</p><p>项目的依赖管理也是件吃力不讨好的事情。决定项目里要用哪些库就已经够让人头痛的了，你还要知道这些库的哪个版本和其他库不会有冲突，这难题实在太棘手。并且，依赖管理也是一种损耗，添加依赖不是写应用程序代码。一旦选错了依赖的版本，随之而来的不兼容问题毫无疑问会是生产力杀手。</p></li></ul><p>而SpringBoot让这一切成为过去！</p><blockquote><p>Spring Boot 简化了基于Spring的应用开发，只需要“run”就能创建一个独立的、生产级别的Spring应用。Spring Boot为Spring平台及第三方库提供开箱即用的设置（提供默认设置，存放默认配置的包就是启动器），这样我们就可以简单的开始。多数Spring Boot应用只需要很少的Spring配置。</p></blockquote><p>我们可以使用SpringBoot创建java应用，并使用java –jar 启动它，就能得到一个生产级别的web工程。</p><h2 id="1-3-SpringBoot的特点"><a href="#1-3-SpringBoot的特点" class="headerlink" title="1.3.SpringBoot的特点"></a>1.3.SpringBoot的特点</h2><p>Spring Boot 主要目标是：</p><ul><li>为所有 Spring 的开发者提供一个非常快速的、广泛接受的入门体验</li><li>开箱即用（启动器starter-其实就是SpringBoot提供的一个jar包），但通过自己设置参数（.properties），即可快速摆脱这种方式。</li><li>提供了一些大型项目中常见的非功能性特性，如内嵌服务器、安全、指标，健康检测、外部化配置等</li><li>绝对没有代码生成，也无需 XML 配置。</li></ul><p>更多细节，大家可以到<a href="http://projects.spring.io/spring-boot/" target="_blank" rel="noopener">官网</a>查看。</p><h1 id="2-快速入门"><a href="#2-快速入门" class="headerlink" title="2.快速入门"></a>2.快速入门</h1><p>接下来，我们就来利用SpringBoot搭建一个web工程，体会一下SpringBoot的魅力所在！</p><h2 id="2-1-创建工程"><a href="#2-1-创建工程" class="headerlink" title="2.1.创建工程"></a>2.1.创建工程</h2><p>我们先新建一个空的工程：</p><p><img src="\blogPic\springboot\1525485888078.png" alt="1525485888078"></p><p>工程名为demo：</p><p> <img src="\blogPic\springboot\1525485977528.png" alt="1525485977528"></p><p>新建一个model：</p><p> <img src="\blogPic\springboot\1525486079389.png" alt="1525486079389"></p><p>使用maven来构建：</p><p><img src="\blogPic\springboot\1525486188374.png" alt="1525486188374"></p><p>然后填写项目坐标：</p><p> <img src="\blogPic\springboot\1525486236967.png" alt="1525486236967"></p><p>目录结构：</p><p> <img src="\blogPic\springboot\1525486282929.png" alt="1525486282929"></p><p>项目结构：</p><p> <img src="\blogPic\springboot\1525486435199.png" alt="1525486435199"></p><h2 id="2-2-添加依赖"><a href="#2-2-添加依赖" class="headerlink" title="2.2.添加依赖"></a>2.2.添加依赖</h2><p>看到这里很多同学会有疑惑，前面说传统开发的问题之一就是依赖管理混乱，怎么这里我们还需要管理依赖呢？难道SpringBoot不帮我们管理吗？</p><p>别着急，现在我们的项目与SpringBoot还没有什么关联。SpringBoot提供了一个名为spring-boot-starter-parent的工程，里面已经对各种常用依赖（并非全部）的版本进行了管理，我们的项目需要以这个项目为父工程，这样我们就不用操心依赖的版本问题了，需要什么依赖，直接引入坐标即可！</p><h3 id="2-2-1-添加父工程坐标"><a href="#2-2-1-添加父工程坐标" class="headerlink" title="2.2.1.添加父工程坐标"></a>2.2.1.添加父工程坐标</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-2-添加web启动器"><a href="#2-2-2-添加web启动器" class="headerlink" title="2.2.2.添加web启动器"></a>2.2.2.添加web启动器</h3><p>为了让SpringBoot帮我们完成各种自动配置，我们必须引入SpringBoot提供的自动配置依赖，我们称为<code>启动器</code>。因为我们是web项目，这里我们引入web启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br></pre></td></tr></table></figure><p>需要注意的是，我们并没有在这里指定版本信息。因为SpringBoot的父工程已经对版本进行了管理了。</p><p>这个时候，我们会发现项目中多出了大量的依赖：</p><p> <img src="\blogPic\springboot\1525486980765.png" alt="1525486980765"></p><p>这些都是SpringBoot根据spring-boot-starter-web这个依赖自动引入的，而且所有的版本都已经管理好，不会出现冲突。</p><h3 id="2-2-3-管理jdk版本"><a href="#2-2-3-管理jdk版本" class="headerlink" title="2.2.3.管理jdk版本"></a>2.2.3.管理jdk版本</h3><p>默认情况下，maven工程的jdk版本是1.5，而我们开发使用的是1.8，因此这里我们需要修改jdk版本，只需要简单的添加以下属性即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br></pre></td></tr></table></figure><h3 id="2-2-4-完整pom"><a href="#2-2-4-完整pom" class="headerlink" title="2.2.4.完整pom"></a>2.2.4.完整pom</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.leyou.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>springboot-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.0.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="2-3-启动类"><a href="#2-3-启动类" class="headerlink" title="2.3.启动类"></a>2.3.启动类</h2><p>Spring Boot项目通过main函数即可启动，我们需要创建一个启动类：</p><p> <img src="\blogPic\springboot\1525487293907.png" alt="1525487293907"></p><p>然后编写main函数：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Application</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(Application.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-4-编写controller"><a href="#2-4-编写controller" class="headerlink" title="2.4.编写controller"></a>2.4.编写controller</h2><p>接下来，我们就可以像以前那样开发SpringMVC的项目了！</p><p>我们编写一个controller：</p><p> <img src="\blogPic\springboot\1525487465325.png" alt="1525487465325"></p><p>代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="2-5-启动测试"><a href="#2-5-启动测试" class="headerlink" title="2.5.启动测试"></a>2.5.启动测试</h2><p>接下来，我们运行main函数，查看控制台：</p><p> <img src="\blogPic\springboot\1525487613365.png" alt="1525487613365"></p><p>并且可以看到监听的端口信息：</p><p> <img src="\blogPic\springboot\1525487705460.png" alt="1525487705460"></p><ul><li>1）监听的端口是8080</li><li>2）SpringMVC的映射路径是：/</li><li>3）<code>/hello</code>路径已经映射到了<code>HelloController</code>中的<code>hello()</code>方法</li></ul><p>打开页面访问：<a href="http://localhost:8080/hello" target="_blank" rel="noopener">http://localhost:8080/hello</a></p><p> <img src="\blogPic\springboot\1525487820824.png" alt="1525487820824"></p><p>测试成功了！</p><h1 id="3-Java配置"><a href="#3-Java配置" class="headerlink" title="3.Java配置"></a>3.Java配置</h1><p>在入门案例中，我们没有任何的配置，就可以实现一个SpringMVC的项目了，快速、高效！</p><p>但是有同学会有疑问，如果没有任何的xml，那么我们如果要配置一个Bean该怎么办？比如我们要配置一个数据库连接池，以前会这么玩：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 配置连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">bean</span> <span class="attr">id</span>=<span class="string">"dataSource"</span> <span class="attr">class</span>=<span class="string">"com.alibaba.druid.pool.DruidDataSource"</span></span></span><br><span class="line"><span class="tag">      <span class="attr">init-method</span>=<span class="string">"init"</span> <span class="attr">destroy-method</span>=<span class="string">"close"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"url"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.url&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"username"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.username&#125;"</span> /&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">property</span> <span class="attr">name</span>=<span class="string">"password"</span> <span class="attr">value</span>=<span class="string">"$&#123;jdbc.password&#125;"</span> /&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">bean</span>&gt;</span></span><br></pre></td></tr></table></figure><p>现在该怎么做呢？</p><h2 id="3-1-回顾历史"><a href="#3-1-回顾历史" class="headerlink" title="3.1.回顾历史"></a>3.1.回顾历史</h2><p>事实上，在Spring3.0开始，Spring官方就已经开始推荐使用java配置来代替传统的xml配置了，我们不妨来回顾一下Spring的历史：</p><ul><li><p>Spring1.0时代</p><p>在此时因为jdk1.5刚刚出来，注解开发并未盛行，因此一切Spring配置都是xml格式，想象一下所有的bean都用xml配置，细思极恐啊，心疼那个时候的程序员2秒</p></li><li><p>Spring2.0时代</p><p>Spring引入了注解开发，但是因为并不完善，因此并未完全替代xml，此时的程序员往往是把xml与注解进行结合，貌似我们之前都是这种方式。</p></li><li><p>Spring3.0及以后</p><p>3.0以后Spring的注解已经非常完善了，因此Spring推荐大家使用完全的java配置来代替以前的xml，不过似乎在国内并未推广盛行。然后当SpringBoot来临，人们才慢慢认识到java配置的优雅。</p></li></ul><p>有句古话说的好：拥抱变化，拥抱未来。所以我们也应该顺应时代潮流，做时尚的弄潮儿，一起来学习下java配置的玩法。</p><h2 id="3-2-尝试java配置"><a href="#3-2-尝试java配置" class="headerlink" title="3.2.尝试java配置"></a>3.2.尝试java配置</h2><p>java配置主要靠java类和一些注解，比较常用的注解有：</p><ul><li><code>@Configuration</code>：声明一个类作为配置类，代替xml文件</li><li><code>@Bean</code>：声明在方法上，将方法的返回值加入Bean容器，代替<code>&lt;bean&gt;</code>标签</li><li><code>@value</code>：属性注入</li><li><code>@PropertySource</code>：指定外部属性文件，</li></ul><p>我们接下来用java配置来尝试实现连接池配置：</p><p>首先引入Druid连接池依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>创建一个jdbc.properties文件，编写jdbc属性：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">jdbc.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line">jdbc.url=jdbc:mysql://127.0.0.1:3306/leyou</span><br><span class="line">jdbc.username=root</span><br><span class="line">jdbc.password=123</span><br></pre></td></tr></table></figure><p>然后编写代码：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@PropertySource</span>(<span class="string">"classpath:jdbc.properties"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.url&#125;"</span>)</span><br><span class="line">    String url;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.driverClassName&#125;"</span>)</span><br><span class="line">    String driverClassName;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.username&#125;"</span>)</span><br><span class="line">    String username;</span><br><span class="line">    <span class="meta">@Value</span>(<span class="string">"$&#123;jdbc.password&#125;"</span>)</span><br><span class="line">    String password;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(url);</span><br><span class="line">        dataSource.setDriverClassName(driverClassName);</span><br><span class="line">        dataSource.setUsername(username);</span><br><span class="line">        dataSource.setPassword(password);</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li><code>@Configuration</code>：声明我们<code>JdbcConfig</code>是一个配置类</li><li><code>@PropertySource</code>：指定属性文件的路径是:<code>classpath:jdbc.properties</code></li><li>通过<code>@Value</code>为属性注入值</li><li>通过@Bean将 <code>dataSource()</code>方法声明为一个注册Bean的方法，Spring会自动调用该方法，将方法的返回值加入Spring容器中。</li></ul><p>然后我们就可以在任意位置通过<code>@Autowired</code>注入DataSource了！</p><p>我们在<code>HelloController</code>中测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DataSource dataSource;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"hello, spring boot!"</span> + dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后Debug运行并查看：</p><p><img src="\blogPic\springboot\1525492528558.png" alt="1525492528558"></p><p>属性注入成功了！</p><h2 id="3-3-SpringBoot的属性注入"><a href="#3-3-SpringBoot的属性注入" class="headerlink" title="3.3.SpringBoot的属性注入"></a>3.3.SpringBoot的属性注入</h2><p>在上面的案例中，我们实验了java配置方式。不过属性注入使用的是@Value注解。这种方式虽然可行，但是不够强大，因为它只能注入基本类型值。</p><p>在SpringBoot中，提供了一种新的属性注入方式，支持各种java基本数据类型及复杂类型的注入。</p><p>1）我们新建一个类，用来进行属性注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcProperties</span> </span>&#123;</span><br><span class="line">    <span class="keyword">private</span> String url;</span><br><span class="line">    <span class="keyword">private</span> String driverClassName;</span><br><span class="line">    <span class="keyword">private</span> String username;</span><br><span class="line">    <span class="keyword">private</span> String password;</span><br><span class="line">    <span class="comment">// ... 略</span></span><br><span class="line">    <span class="comment">// getters 和 setters</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>在类上通过@ConfigurationProperties注解声明当前类为属性读取类</p></li><li><p><code>prefix=&quot;jdbc&quot;</code>读取属性文件中，前缀为jdbc的值。</p></li><li><p>在类上定义各个属性，名称必须与属性文件中<code>jdbc.</code>后面部分一致</p></li><li><p>需要注意的是，这里我们并没有指定属性文件的地址，所以我们需要把jdbc.properties名称改为application.properties，这是SpringBoot默认读取的属性文件名：</p><p> <img src="\blogPic\springboot\1525496325572.png" alt="1525496325572"></p></li></ul><p>2）在JdbcConfig中使用这个属性：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="meta">@EnableConfigurationProperties</span>(JdbcProperties.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">(JdbcProperties jdbc)</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        dataSource.setUrl(jdbc.getUrl());</span><br><span class="line">        dataSource.setDriverClassName(jdbc.getDriverClassName());</span><br><span class="line">        dataSource.setUsername(jdbc.getUsername());</span><br><span class="line">        dataSource.setPassword(jdbc.getPassword());</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>通过<code>@EnableConfigurationProperties(JdbcProperties.class)</code>来声明要使用<code>JdbcProperties</code>这个类的对象</p></li><li><p>然后你可以通过以下方式注入JdbcProperties：</p><ul><li><p>@Autowired注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br></pre></td></tr></table></figure></li><li><p>构造函数注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> JdbcProperties prop;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">JdbcConfig</span><span class="params">(Jdbcproperties prop)</span></span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.prop = prop;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>声明有@Bean的方法参数注入</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> Datasource <span class="title">dataSource</span><span class="params">(JdbcProperties prop)</span></span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul></li></ul><p>本例中，我们采用第三种方式。</p><p>3）测试结果：</p><p><img src="\blogPic\springboot\1525492528558.png" alt="1525492528558"></p><p>大家会觉得这种方式似乎更麻烦了，事实上这种方式有更强大的功能，也是SpringBoot推荐的注入方式。两者对比关系：</p><p><img src="\blogPic\springboot\1525496543249.png" alt="1525496543249"></p><p>优势：</p><ul><li><p>Relaxed binding：松散绑定</p><ul><li><p>不严格要求属性文件中的属性名与成员变量名一致。支持驼峰，中划线，下划线等等转换，甚至支持对象引导。比如：user.friend.name：代表的是user对象中的friend属性中的name属性，显然friend也是对象。@value注解就难以完成这样的注入方式。</p></li><li><p>meta-data support：元数据支持，帮助IDE生成属性提示（写开源框架会用到）。</p><p>​</p></li></ul></li></ul><h2 id="3-4、更优雅的注入"><a href="#3-4、更优雅的注入" class="headerlink" title="3.4、更优雅的注入"></a>3.4、更优雅的注入</h2><p>事实上，如果一段属性只有一个Bean需要使用，我们无需将其注入到一个类（JdbcProperties）中。而是直接在需要的地方声明即可：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">JdbcConfig</span> </span>&#123;</span><br><span class="line">    </span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="comment">// 声明要注入的属性前缀，SpringBoot会自动把相关属性通过set方法注入到DataSource中</span></span><br><span class="line">    <span class="meta">@ConfigurationProperties</span>(prefix = <span class="string">"jdbc"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> DataSource <span class="title">dataSource</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        DruidDataSource dataSource = <span class="keyword">new</span> DruidDataSource();</span><br><span class="line">        <span class="keyword">return</span> dataSource;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们直接把<code>@ConfigurationProperties(prefix = &quot;jdbc&quot;)</code>声明在需要使用的<code>@Bean</code>的方法上，然后SpringBoot就会自动调用这个Bean（此处是DataSource）的set方法，然后完成注入。使用的前提是：<strong>该类必须有对应属性的set方法！</strong></p><p>我们将jdbc的url改成：/heima，再次测试：</p><p><img src="\blogPic\springboot\1525497513206.png" alt="1525497513206"></p><h1 id="4-自动配置原理"><a href="#4-自动配置原理" class="headerlink" title="4.自动配置原理"></a>4.自动配置原理</h1><p>使用SpringBoot之后，一个整合了SpringMVC的WEB工程开发，变的无比简单，那些繁杂的配置都消失不见了，这是如何做到的？</p><p>一切魔力的开始，都是从我们的main函数来的，所以我们再次来看下启动类：</p><p> <img src="\blogPic\springboot\1525488044650.png" alt="1525488044650"></p><p>我们发现特别的地方有两个：</p><ul><li>注解：@SpringBootApplication</li><li>run方法：SpringApplication.run()</li></ul><p>我们分别来研究这两个部分。</p><h2 id="4-1-了解-SpringBootApplication"><a href="#4-1-了解-SpringBootApplication" class="headerlink" title="4.1.了解@SpringBootApplication"></a>4.1.了解@SpringBootApplication</h2><p>点击进入，查看源码：</p><p><img src="\blogPic\springboot\1525488226710.png" alt="1525488226710"></p><p>这里重点的注解有3个：</p><ul><li>@SpringBootConfiguration</li><li>@EnableAutoConfiguration</li><li>@ComponentScan</li></ul><h3 id="4-1-1-SpringBootConfiguration"><a href="#4-1-1-SpringBootConfiguration" class="headerlink" title="4.1.1.@SpringBootConfiguration"></a>4.1.1.@SpringBootConfiguration</h3><p>我们继续点击查看源码：</p><p><img src="\blogPic\springboot\1525488518514.png" alt="1525488518514"></p><p>通过这段我们可以看出，在这个注解上面，又有一个<code>@Configuration</code>注解。通过上面的注释阅读我们知道：这个注解的作用就是声明当前类是一个配置类，然后Spring会自动扫描到添加了<code>@Configuration</code>的类，并且读取其中的配置信息。而<code>@SpringBootConfiguration</code>是来声明当前类是SpringBoot应用的配置类，项目中只能有一个。所以一般我们无需自己添加。</p><h3 id="4-1-2-EnableAutoConfiguration"><a href="#4-1-2-EnableAutoConfiguration" class="headerlink" title="4.1.2.@EnableAutoConfiguration"></a>4.1.2.@EnableAutoConfiguration</h3><p>关于这个注解，官网上有一段说明：</p><blockquote><p>The second class-level annotation is <code>@EnableAutoConfiguration</code>. This annotation<br>tells Spring Boot to “guess” how you want to configure Spring, based on the jar<br>dependencies that you have added. Since <code>spring-boot-starter-web</code> added Tomcat<br>and Spring MVC, the auto-configuration assumes that you are developing a web<br>application and sets up Spring accordingly.</p></blockquote><p>简单翻译以下：</p><blockquote><p>第二级的注解<code>@EnableAutoConfiguration</code>，告诉SpringBoot基于你所添加的依赖，去“猜测”你想要如何配置Spring。比如我们引入了<code>spring-boot-starter-web</code>，而这个启动器中帮我们添加了<code>tomcat</code>、<code>SpringMVC</code>的依赖。此时自动配置就知道你是要开发一个web应用，所以就帮你完成了web及SpringMVC的默认配置了！</p></blockquote><p>总结，SpringBoot内部对大量的第三方库或Spring内部库进行了默认配置，这些配置是否生效，取决于我们是否引入了对应库所需的依赖，如果有那么默认配置就会生效。</p><p>所以，我们使用SpringBoot构建一个项目，只需要引入所需框架的依赖，配置就可以交给SpringBoot处理了。除非你不希望使用SpringBoot的默认配置，它也提供了自定义配置的入口。</p><h4 id="4-1-3-ComponentScan"><a href="#4-1-3-ComponentScan" class="headerlink" title="4.1.3.@ComponentScan"></a>4.1.3.@ComponentScan</h4><p>我们跟进源码：</p><p> <img src="\blogPic\springboot\1525498265579.png" alt="1525498265579"></p><p>并没有看到什么特殊的地方。我们查看注释：</p><p> <img src="\blogPic\springboot\1525498351385.png" alt="1525498351385"></p><p>大概的意思：</p><blockquote><p>配置组件扫描的指令。提供了类似与<code>&lt;context:component-scan&gt;</code>标签的作用</p><p>通过basePackageClasses或者basePackages属性来指定要扫描的包。如果没有指定这些属性，那么将从声明这个注解的类所在的包开始，扫描包及子包</p></blockquote><p>而我们的@SpringBootApplication注解声明的类就是main函数所在的启动类，因此扫描的包是该类所在包及其子包。因此，<strong>一般启动类会放在一个比较前的包目录中。</strong></p><h2 id="4-2-默认配置原理"><a href="#4-2-默认配置原理" class="headerlink" title="4.2.默认配置原理"></a>4.2.默认配置原理</h2><h3 id="4-2-1默认配置类"><a href="#4-2-1默认配置类" class="headerlink" title="4.2.1默认配置类"></a>4.2.1默认配置类</h3><p>通过刚才的学习，我们知道@EnableAutoConfiguration会开启SpringBoot的自动配置，并且根据你引入的依赖来生效对应的默认配置。那么问题来了：</p><ul><li>这些默认配置是在哪里定义的呢？</li><li>为何依赖引入就会触发配置呢？</li></ul><p>其实在我们的项目中，已经引入了一个依赖：spring-boot-autoconfigure，其中定义了大量自动配置类：</p><p> <img src="\blogPic\springboot\1525499397690.png" alt="1525499397690"></p><p>还有：</p><p> <img src="\blogPic\springboot\1525499426598.png" alt="1525499426598"></p><p>非常多，几乎涵盖了现在主流的开源框架，例如：</p><ul><li>redis</li><li>jms</li><li>amqp</li><li>jdbc</li><li>jackson</li><li>mongodb</li><li>jpa</li><li>solr</li><li>elasticsearch</li></ul><p>… 等等</p><p>我们来看一个我们熟悉的，例如SpringMVC，查看mvc 的自动配置类：</p><p> <img src="\blogPic\springboot\1525499859426.png" alt="1525499859426"></p><p>打开WebMvcAutoConfiguration：</p><p><img src="\blogPic\springboot\1525500000816.png" alt="1525500000816"></p><p>我们看到这个类上的4个注解：</p><ul><li><code>@Configuration</code>：声明这个类是一个配置类</li></ul><ul><li><p><code>@ConditionalOnWebApplication(type = Type.SERVLET)</code></p><p>ConditionalOn，翻译就是在某个条件下，此处就是满足项目的类是是Type.SERVLET类型，也就是一个普通web工程，显然我们就是</p></li><li><p><code>@ConditionalOnClass({ Servlet.class, DispatcherServlet.class, WebMvcConfigurer.class })</code></p><p>这里的条件是OnClass，也就是满足以下类存在：Servlet、DispatcherServlet、WebMvcConfigurer，其中Servlet只要引入了tomcat依赖自然会有，后两个需要引入SpringMVC才会有。这里就是判断你是否引入了相关依赖，引入依赖后该条件成立，当前类的配置才会生效！</p></li><li><p><code>@ConditionalOnMissingBean(WebMvcConfigurationSupport.class)</code></p><p>这个条件与上面不同，OnMissingBean，是说环境中没有指定的Bean这个才生效。其实这就是自定义配置的入口，也就是说，如果我们自己配置了一个WebMVCConfigurationSupport的类，那么这个默认配置就会失效！</p></li></ul><p>接着，我们查看该类中定义了什么：</p><p>视图解析器：</p><p> <img src="\blogPic\springboot\1525500405278.png" alt="1525500405278"></p><p>处理器适配器（HandlerAdapter）：</p><p> <img src="\blogPic\springboot\1525500452517.png" alt="1525500452517"></p><p>还有很多，这里就不一一截图了。</p><h3 id="4-2-2-默认配置属性"><a href="#4-2-2-默认配置属性" class="headerlink" title="4.2.2.默认配置属性"></a>4.2.2.默认配置属性</h3><p>另外，这些默认配置的属性来自哪里呢？</p><p><img src="\blogPic\springboot\1525500697391.png" alt="1525500697391"></p><p>我们看到，这里通过@EnableAutoConfiguration注解引入了两个属性：WebMvcProperties和ResourceProperties。这不正是SpringBoot的属性注入玩法嘛。</p><p>我们查看这两个属性类：</p><p> <img src="\blogPic\springboot\1525500810914.png" alt="1525500810914"></p><p>找到了内部资源视图解析器的prefix和suffix属性。</p><p>ResourceProperties中主要定义了静态资源（.js,.html,.css等)的路径：</p><p> <img src="\blogPic\springboot\1525500921773.png" alt="1525500921773"></p><p>如果我们要覆盖这些默认属性，只需要在application.properties中定义与其前缀prefix和字段名一致的属性即可。</p><h2 id="4-3-总结"><a href="#4-3-总结" class="headerlink" title="4.3.总结"></a>4.3.总结</h2><p>SpringBoot为我们提供了默认配置，而默认配置生效的条件一般有两个：</p><ul><li>你引入了相关依赖</li><li>你自己没有配置</li></ul><p>1）启动器</p><p>所以，我们如果不想配置，只需要引入依赖即可，而依赖版本我们也不用操心，因为只要引入了SpringBoot提供的stater（启动器），就会自动管理依赖及版本了。</p><p>因此，玩SpringBoot的第一件事情，就是找启动器，SpringBoot提供了大量的默认启动器，参考课前资料中提供的《SpringBoot启动器.txt》</p><p>2）全局配置</p><p>另外，SpringBoot的默认配置，都会读取默认属性，而这些属性可以通过自定义<code>application.properties</code>文件来进行覆盖。这样虽然使用的还是默认配置，但是配置中的值改成了我们自定义的。</p><p>因此，玩SpringBoot的第二件事情，就是通过<code>application.properties</code>来覆盖默认属性值，形成自定义配置。我们需要知道SpringBoot的默认属性key，非常多，参考课前资料提供的：《SpringBoot全局属性.md》</p><h1 id="5-SpringBoot实践"><a href="#5-SpringBoot实践" class="headerlink" title="5.SpringBoot实践"></a>5.SpringBoot实践</h1><p>接下来，我们来看看如何用SpringBoot来玩转以前的SSM,我们沿用之前讲解SSM用到的数据库tb_user和实体类User</p><h2 id="5-1-整合SpringMVC"><a href="#5-1-整合SpringMVC" class="headerlink" title="5.1.整合SpringMVC"></a>5.1.整合SpringMVC</h2><p>虽然默认配置已经可以使用SpringMVC了，不过我们有时候需要进行自定义配置。</p><h3 id="5-1-1-修改端口"><a href="#5-1-1-修改端口" class="headerlink" title="5.1.1.修改端口"></a>5.1.1.修改端口</h3><p>查看SpringBoot的全局属性可知，端口通过以下方式配置：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 映射端口</span><br><span class="line">server.port=80</span><br></pre></td></tr></table></figure><p>重启服务后测试：</p><p> <img src="\blogPic\springboot\1525511878440.png" alt="1525511878440"></p><h3 id="5-1-2-访问静态资源"><a href="#5-1-2-访问静态资源" class="headerlink" title="5.1.2.访问静态资源"></a>5.1.2.访问静态资源</h3><p>现在，我们的项目是一个jar工程，那么就没有webapp，我们的静态资源该放哪里呢？</p><p>回顾我们上面看的源码，有一个叫做ResourceProperties的类，里面就定义了静态资源的默认查找路径：</p><p> <img src="\blogPic\springboot\1525500921773.png" alt="1525500921773"></p><p>默认的静态资源路径为：</p><ul><li>classpath:/META-INF/resources/</li><li>classpath:/resources/</li><li>classpath:/static/</li><li>classpath:/public</li></ul><p>只要静态资源放在这些目录中任何一个，SpringMVC都会帮我们处理。</p><p>我们习惯会把静态资源放在<code>classpath:/static/</code>目录下。我们创建目录，并且添加一些静态资源：</p><p> <img src="\blogPic\springboot\1525512196866.png" alt="1525512196866"></p><p>重启项目后测试：</p><p> <img src="\blogPic\springboot\1525512253682.png" alt="1525512253682"></p><h3 id="5-1-3-添加拦截器"><a href="#5-1-3-添加拦截器" class="headerlink" title="5.1.3.添加拦截器"></a>5.1.3.添加拦截器</h3><p>拦截器也是我们经常需要使用的，在SpringBoot中该如何配置呢？</p><p>拦截器不是一个普通属性，而是一个类，所以就要用到java配置方式了。在SpringBoot官方文档中有这么一段说明：</p><blockquote><p>If you want to keep Spring Boot MVC features and you want to add additional <a href="https://docs.spring.io/spring/docs/5.0.5.RELEASE/spring-framework-reference/web.html#mvc" target="_blank" rel="noopener">MVC configuration</a> (interceptors, formatters, view controllers, and other features), you can add your own <code>@Configuration</code> class of type <code>WebMvcConfigurer</code> but <strong>without</strong> <code>@EnableWebMvc</code>. If you wish to provide custom instances of <code>RequestMappingHandlerMapping</code>, <code>RequestMappingHandlerAdapter</code>, or <code>ExceptionHandlerExceptionResolver</code>, you can declare a <code>WebMvcRegistrationsAdapter</code> instance to provide such components.</p><p>If you want to take complete control of Spring MVC, you can add your own <code>@Configuration</code> annotated with <code>@EnableWebMvc</code>.</p></blockquote><p>翻译：</p><blockquote><p>如果你想要保持Spring Boot 的一些默认MVC特征，同时又想自定义一些MVC配置（包括：拦截器，格式化器, 视图控制器、消息转换器 等等），你应该让一个类实现<code>WebMvcConfigurer</code>，并且添加<code>@Configuration</code>注解，但是<strong>千万不要</strong>加<code>@EnableWebMvc</code>注解。如果你想要自定义<code>HandlerMapping</code>、<code>HandlerAdapter</code>、<code>ExceptionResolver</code>等组件，你可以创建一个<code>WebMvcRegistrationsAdapter</code>实例 来提供以上组件。</p><p>如果你想要完全自定义SpringMVC，不保留SpringBoot提供的一切特征，你可以自己定义类并且添加<code>@Configuration</code>注解和<code>@EnableWebMvc</code>注解</p></blockquote><p>总结：通过实现<code>WebMvcConfigurer</code>并添加<code>@Configuration</code>注解来实现自定义部分SpringMvc配置。</p><p>首先我们定义一个拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoginInterceptor</span> <span class="keyword">implements</span> <span class="title">HandlerInterceptor</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Logger logger = LoggerFactory.getLogger(LoginInterceptor.class);</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">boolean</span> <span class="title">preHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"preHandle method is now running!"</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">postHandle</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, ModelAndView modelAndView)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"postHandle method is now running!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">afterCompletion</span><span class="params">(HttpServletRequest request, HttpServletResponse response, Object handler, Exception ex)</span> </span>&#123;</span><br><span class="line">        logger.debug(<span class="string">"afterCompletion method is now running!"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后，我们定义配置类，注册拦截器：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Configuration</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MvcConfig</span> <span class="keyword">implements</span> <span class="title">WebMvcConfigurer</span></span>&#123;</span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 通过<span class="doctag">@Bean</span>注解，将我们定义的拦截器注册到Spring容器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@return</span></span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> LoginInterceptor <span class="title">loginInterceptor</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> LoginInterceptor();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/**</span></span><br><span class="line"><span class="comment">     * 重写接口中的addInterceptors方法，添加自定义拦截器</span></span><br><span class="line"><span class="comment">     * <span class="doctag">@param</span> registry</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">addInterceptors</span><span class="params">(InterceptorRegistry registry)</span> </span>&#123;</span><br><span class="line">        <span class="comment">// 通过registry来注册拦截器，通过addPathPatterns来添加拦截路径</span></span><br><span class="line">        registry.addInterceptor(<span class="keyword">this</span>.loginInterceptor()).addPathPatterns(<span class="string">"/**"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结构如下：</p><p> <img src="\blogPic\springboot\1525513555179.png" alt="1525513555179"></p><p>接下来运行并查看日志：</p><p>你会发现日志中什么都没有，因为我们记录的log级别是debug，默认是显示info以上，我们需要进行配置。</p><p>SpringBoot通过<code>logging.level.*=debug</code>来配置日志级别，*填写包名</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 设置com.leyou包的日志级别为debug</span><br><span class="line">logging.level.com.leyou=debug</span><br></pre></td></tr></table></figure><p>再次运行查看：</p><figure class="highlight verilog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.811</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : preHandle method is now running!</span><br><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.854</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : postHandle method is now running!</span><br><span class="line"><span class="number">2018</span>-<span class="number">05</span>-<span class="number">05</span> <span class="number">17</span>:<span class="number">50</span>:<span class="number">01</span><span class="variable">.854</span> DEBUG <span class="number">4548</span> --- [p-nio-<span class="number">80</span>-exec-<span class="number">1</span>] com<span class="variable">.leyou</span><span class="variable">.interceptor</span><span class="variable">.LoginInterceptor</span>   : afterCompletion method is now running!</span><br></pre></td></tr></table></figure><h2 id="5-2-整合jdbc和事务"><a href="#5-2-整合jdbc和事务" class="headerlink" title="5.2.整合jdbc和事务"></a>5.2.整合jdbc和事务</h2><p>spring中的jdbc连接和事务是配置中的重要一环，在SpringBoot中该如何处理呢？</p><p>答案是不需要处理，我们只要找到SpringBoot提供的启动器即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-jdbc<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>当然，不要忘了数据库驱动，SpringBoot并不知道我们用的什么数据库，这里我们选择MySQL：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>至于事务，SpringBoot中通过注解来控制。就是我们熟知的<code>@Transactional</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Transactional</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">deleteById</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">        <span class="keyword">this</span>.userMapper.deleteByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-3-整合连接池"><a href="#5-3-整合连接池" class="headerlink" title="5.3.整合连接池"></a>5.3.整合连接池</h2><p>其实，在刚才引入jdbc启动器的时候，SpringBoot已经自动帮我们引入了一个连接池：</p><p> <img src="\blogPic\springboot\1525514424562.png" alt="1525514424562"></p><p>HikariCP应该是目前速度最快的连接池了，我们看看它与c3p0的对比：</p><p> <img src="\blogPic\springboot\1525516441005.png" alt="1525516441005"></p><p>因此，我们只需要指定连接池参数即可：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"># 连接四大参数</span><br><span class="line">spring.datasource.url=jdbc:mysql://localhost:3306/heima</span><br><span class="line">spring.datasource.username=root</span><br><span class="line">spring.datasource.password=123</span><br><span class="line"># 可省略，SpringBoot自动推断</span><br><span class="line">spring.datasource.driverClassName=com.mysql.jdbc.Driver</span><br><span class="line"></span><br><span class="line">spring.datasource.hikari.idle-timeout=60000</span><br><span class="line">spring.datasource.hikari.maximum-pool-size=30</span><br><span class="line">spring.datasource.hikari.minimum-idle=10</span><br></pre></td></tr></table></figure><p>当然，如果你更喜欢Druid连接池，也可以使用Druid官方提供的启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Druid连接池 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.alibaba<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>druid-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.1.6<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>而连接信息的配置与上面是类似的，只不过在连接池特有属性上，方式略有不同：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">#初始化连接数</span><br><span class="line">spring.datasource.druid.initial-size=1</span><br><span class="line">#最小空闲连接</span><br><span class="line">spring.datasource.druid.min-idle=1</span><br><span class="line">#最大活动连接</span><br><span class="line">spring.datasource.druid.max-active=20</span><br><span class="line">#获取连接时测试是否可用</span><br><span class="line">spring.datasource.druid.test-on-borrow=true</span><br><span class="line">#监控页面启动</span><br><span class="line">spring.datasource.druid.stat-view-servlet.allow=true</span><br></pre></td></tr></table></figure><h2 id="5-4-整合mybatis"><a href="#5-4-整合mybatis" class="headerlink" title="5.4.整合mybatis"></a>5.4.整合mybatis</h2><h3 id="5-4-1-mybatis"><a href="#5-4-1-mybatis" class="headerlink" title="5.4.1.mybatis"></a>5.4.1.mybatis</h3><p>SpringBoot官方并没有提供Mybatis的启动器，不过Mybatis<a href="https://github.com/mybatis/spring-boot-starter" target="_blank" rel="noopener">官网</a>自己实现了：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!--mybatis --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.mybatis.spring.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mybatis-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.3.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>配置，基本没有需要配置的：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"># mybatis 别名扫描</span><br><span class="line">mybatis.type-aliases-package=com.heima.pojo</span><br><span class="line"># mapper.xml文件位置,如果没有映射文件，请注释掉</span><br><span class="line">mybatis.mapper-locations=classpath:mappers/*.xml</span><br></pre></td></tr></table></figure><p>需要注意，这里没有配置mapper接口扫描包，因此我们需要给每一个Mapper接口添加<code>@Mapper</code>注解，才能被识别。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> </span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="5-4-2-通用mapper"><a href="#5-4-2-通用mapper" class="headerlink" title="5.4.2.通用mapper"></a>5.4.2.通用mapper</h3><p>通用Mapper的作者也为自己的插件编写了启动器，我们直接引入即可：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- 通用mapper --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.2<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>不需要做任何配置就可以使用了。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Mapper</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">tk</span>.<span class="title">mybatis</span>.<span class="title">mapper</span>.<span class="title">common</span>.<span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="5-5-启动测试"><a href="#5-5-启动测试" class="headerlink" title="5.5.启动测试"></a>5.5.启动测试</h2><p>将controller进行简单改造：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HelloController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/hello"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">hello</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        User user = <span class="keyword">this</span>.userService.queryById(<span class="number">8L</span>);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>我们启动项目，查看：</p><p> <img src="\blogPic\springboot\1525516714124.png" alt="1525516714124"></p><h1 id="6-Thymeleaf快速入门"><a href="#6-Thymeleaf快速入门" class="headerlink" title="6.Thymeleaf快速入门"></a>6.Thymeleaf快速入门</h1><p>SpringBoot并不推荐使用jsp，但是支持一些模板引擎技术：</p><p><img src="\blogPic\springboot\1525517263421.png" alt="1525517263421"></p><p>以前大家用的比较多的是Freemarker，但是我们今天的主角是Thymeleaf！</p><h2 id="6-1-为什么是Thymeleaf？"><a href="#6-1-为什么是Thymeleaf？" class="headerlink" title="6.1.为什么是Thymeleaf？"></a>6.1.为什么是Thymeleaf？</h2><p>简单说， Thymeleaf 是一个跟 Velocity、FreeMarker 类似的模板引擎，它可以完全替代 JSP 。相较与其他的模板引擎，它有如下三个极吸引人的特点：</p><ul><li>动静结合：Thymeleaf 在有网络和无网络的环境下皆可运行，即它可以让美工在浏览器查看页面的静态效果，也可以让程序员在服务器查看带数据的动态页面效果。这是由于它支持 html 原型，然后在 html 标签里增加额外的属性来达到模板+数据的展示方式。浏览器解释 html 时会忽略未定义的标签属性，所以 thymeleaf 的模板可以静态地运行；当有数据返回到页面时，Thymeleaf 标签会动态地替换掉静态内容，使页面动态显示。</li><li>开箱即用：它提供标准和spring标准两种方言，可以直接套用模板实现JSTL、 OGNL表达式效果，避免每天套模板、该jstl、改标签的困扰。同时开发人员也可以扩展和创建自定义的方言。</li><li>多方言支持：Thymeleaf 提供spring标准方言和一个与 SpringMVC 完美集成的可选模块，可以快速的实现表单绑定、属性编辑器、国际化等功能。</li><li>与SpringBoot完美整合，SpringBoot提供了Thymeleaf的默认配置，并且为Thymeleaf设置了视图解析器，我们可以像以前操作jsp一样来操作Thymeleaf。代码几乎没有任何区别，就是在模板语法上有区别。</li></ul><p>接下来，我们就通过入门案例来体会Thymeleaf的魅力：</p><h2 id="6-2-编写接口"><a href="#6-2-编写接口" class="headerlink" title="6.2.编写接口"></a>6.2.编写接口</h2><p>编写一个controller，返回一些用户数据，放入模型中，等会在页面渲染</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"/all"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">all</span><span class="params">(ModelMap model)</span> </span>&#123;</span><br><span class="line">    <span class="comment">// 查询用户</span></span><br><span class="line">    List&lt;User&gt; users = <span class="keyword">this</span>.userService.queryAll();</span><br><span class="line">    <span class="comment">// 放入模型</span></span><br><span class="line">    model.addAttribute(<span class="string">"users"</span>, users);</span><br><span class="line">    <span class="comment">// 返回模板名称（就是classpath:/templates/目录下的html文件名）</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"users"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="6-3-引入启动器"><a href="#6-3-引入启动器" class="headerlink" title="6.3.引入启动器"></a>6.3.引入启动器</h2><p>直接引入启动器：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-thymeleaf<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>SpringBoot会自动为Thymeleaf注册一个视图解析器：</p><p> <img src="\blogPic\springboot\1525522481007.png" alt="1525522481007"></p><p>与解析JSP的InternalViewResolver类似，Thymeleaf也会根据前缀和后缀来确定模板文件的位置：</p><p> <img src="\blogPic\springboot\1525522811359.png" alt="1525522811359"></p><ul><li>默认前缀：<code>classpath:/templates/</code></li><li>默认后缀：<code>.html</code></li></ul><p>所以如果我们返回视图：<code>users</code>，会指向到 <code>classpath:/templates/users.html</code></p><p>一般我们无需进行修改，默认即可。</p><h2 id="6-4-静态页面"><a href="#6-4-静态页面" class="headerlink" title="6.4.静态页面"></a>6.4.静态页面</h2><p>根据上面的文档介绍，模板默认放在classpath下的templates文件夹，我们新建一个html文件放入其中：</p><p> <img src="\blogPic\springboot\1525521721279.png" alt="1525521721279"></p><p>编写html模板，渲染模型中的数据：</p><p>注意，把html 的名称空间，改成：<code>xmlns:th=&quot;http://www.thymeleaf.org&quot;</code> 会有语法提示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;!DOCTYPE html&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">html</span> <span class="attr">xmlns:th</span>=<span class="string">"http://www.thymeleaf.org"</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">head</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">meta</span> <span class="attr">charset</span>=<span class="string">"UTF-8"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">title</span>&gt;</span>首页<span class="tag">&lt;/<span class="name">title</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span> <span class="attr">type</span>=<span class="string">"text/css"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="undefined">        table &#123;border-collapse: collapse; font-size: 14px; width: 80%; margin: auto&#125;</span></span><br><span class="line"><span class="undefined">        table, th, td &#123;border: 1px solid darkslategray;padding: 10px&#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">head</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">style</span>=<span class="string">"text-align: center"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">span</span> <span class="attr">style</span>=<span class="string">"color: darkslategray; font-size: 30px"</span>&gt;</span>欢迎光临！<span class="tag">&lt;/<span class="name">span</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">hr</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">table</span> <span class="attr">class</span>=<span class="string">"list"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>id<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>用户名<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>生日<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">th</span>&gt;</span>备注<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tr</span> <span class="attr">th:each</span>=<span class="string">"user : $&#123;users&#125;"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.id&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.name&#125;"</span>&gt;</span>张三<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.userName&#125;"</span>&gt;</span>zhangsan<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.age&#125;"</span>&gt;</span>20<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.sex&#125; == 1 ? '男': '女'"</span>&gt;</span>男<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;#dates.format(user.birthday, 'yyyy-MM-dd')&#125;"</span>&gt;</span>1980-02-30<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">td</span> <span class="attr">th:text</span>=<span class="string">"$&#123;user.note&#125;"</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">body</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">html</span>&gt;</span></span><br></pre></td></tr></table></figure><p>我们看到这里使用了以下语法：</p><ul><li><code>${}</code> ：这个类似与el表达式，但其实是ognl的语法，比el表达式更加强大</li><li><code>th-</code>指令：<code>th-</code>是利用了Html5中的自定义属性来实现的。如果不支持H5，可以用<code>data-th-</code>来代替<ul><li><code>th:each</code>：类似于<code>c:foreach</code>  遍历集合，但是语法更加简洁</li><li><code>th:text</code>：声明标签中的文本<ul><li>例如<code>&lt;td th-text=&#39;${user.id}&#39;&gt;1&lt;/td&gt;</code>，如果user.id有值，会覆盖默认的1</li><li>如果没有值，则会显示td中默认的1。这正是thymeleaf能够动静结合的原因，模板解析失败不影响页面的显示效果，因为会显示默认值！</li></ul></li></ul></li></ul><h2 id="6-5-测试"><a href="#6-5-测试" class="headerlink" title="6.5.测试"></a>6.5.测试</h2><p>接下来，我们打开页面测试一下：</p><p><img src="\blogPic\springboot\1525523911854.png" alt="1525523911854"></p><h2 id="6-6-模板缓存"><a href="#6-6-模板缓存" class="headerlink" title="6.6.模板缓存"></a>6.6.模板缓存</h2><p>Thymeleaf会在第一次对模板解析之后进行缓存，极大的提高了并发处理能力。但是这给我们开发带来了不便，修改页面后并不会立刻看到效果，我们开发阶段可以关掉缓存使用：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># 开发阶段关闭thymeleaf的模板缓存</span><br><span class="line">spring.thymeleaf.cache=false</span><br></pre></td></tr></table></figure><p><strong>注意</strong>：</p><p>​    在Idea中，我们需要在修改页面后按快捷键：<code>Ctrl + Shift + F9</code> 对项目进行rebuild才可以。</p><p>​    eclipse中没有测试过。</p><p>我们可以修改页面，测试一下。</p>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;这是Springboot的相关学习&quot;&gt;&lt;a href=&quot;#这是Springboot的相关学习&quot; class=&quot;headerlink&quot; title=&quot;这是Springboot的相关学习&quot;&gt;&lt;/a&gt;这是Springboot的相关学习&lt;/h1&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>springcloud</title>
    <link href="http://yoursite.com/2019/01/17/springcloud/"/>
    <id>http://yoursite.com/2019/01/17/springcloud/</id>
    <published>2019-01-17T06:33:02.000Z</published>
    <updated>2019-01-17T06:50:18.640Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringCloud基础学习"><a href="#SpringCloud基础学习" class="headerlink" title="SpringCloud基础学习"></a>SpringCloud基础学习</h1><a id="more"></a><h1 id="0-学习目标"><a href="#0-学习目标" class="headerlink" title="0.学习目标"></a>0.学习目标</h1><ul><li>了解系统架构的演变</li><li>了解RPC与Http的区别</li><li>掌握HttpClient的简单使用</li><li>知道什么是SpringCloud</li><li>独立搭建Eureka注册中心</li><li>独立配置Robbin负载均衡</li></ul><h1 id="1-系统架构演变"><a href="#1-系统架构演变" class="headerlink" title="1.系统架构演变"></a>1.系统架构演变</h1><p>随着互联网的发展，网站应用的规模不断扩大。需求的激增，带来的是技术上的压力。系统架构也因此也不断的演进、升级、迭代。从单一应用，到垂直拆分，到分布式服务，到SOA，以及现在火热的微服务架构，还有在Google带领下来势汹涌的Service Mesh。我们到底是该乘坐微服务的船只驶向远方，还是偏安一隅得过且过？</p><p>其实生活不止眼前的苟且，还有诗和远方。所以我们今天就回顾历史，看一看系统架构演变的历程；把握现在，学习现在最火的技术架构；展望未来，争取成为一名优秀的Java工程师。</p><h2 id="1-1-集中式架构"><a href="#1-1-集中式架构" class="headerlink" title="1.1. 集中式架构"></a>1.1. 集中式架构</h2><p>当网站流量很小时，只需一个应用，将所有功能都部署在一起，以减少部署节点和成本。此时，用于简化增删改查工作量的数据访问框架(ORM)是影响项目开发的关键。</p><p> <img src="\blogPic\springcloud1\1525529091749.png" alt="1525529091749"></p><p>存在的问题：</p><ul><li>代码耦合，开发维护困难</li><li>无法针对不同模块进行针对性优化</li><li>无法水平扩展</li><li>单点容错率低，并发能力差</li></ul><h2 id="1-2-垂直拆分"><a href="#1-2-垂直拆分" class="headerlink" title="1.2.垂直拆分"></a>1.2.垂直拆分</h2><p>当访问量逐渐增大，单一应用无法满足需求，此时为了应对更高的并发和业务需求，我们根据业务功能对系统进行拆分：</p><p> <img src="\blogPic\springcloud1\1525529671801.png" alt="1525529671801"></p><p>优点：</p><ul><li>系统拆分实现了流量分担，解决了并发问题</li><li>可以针对不同模块进行优化</li><li>方便水平扩展，负载均衡，容错率提高</li></ul><p>缺点：</p><ul><li>系统间相互独立，会有很多重复开发工作，影响开发效率</li></ul><h2 id="1-3-分布式服务"><a href="#1-3-分布式服务" class="headerlink" title="1.3.分布式服务"></a>1.3.分布式服务</h2><p>当垂直应用越来越多，应用之间交互不可避免，将核心业务抽取出来，作为独立的服务，逐渐形成稳定的服务中心，使前端应用能更快速的响应多变的市场需求。此时，用于提高业务复用及整合的分布式调用是关键。</p><p> <img src="\blogPic\springcloud1\1525530657919.png" alt="1525530657919"></p><p>优点：</p><ul><li>将基础服务进行了抽取，系统间相互调用，提高了代码复用和开发效率</li></ul><p>缺点：</p><ul><li>系统间耦合度变高，调用关系错综复杂，难以维护</li></ul><h2 id="1-4-流动计算架构（SOA）"><a href="#1-4-流动计算架构（SOA）" class="headerlink" title="1.4.流动计算架构（SOA）"></a>1.4.流动计算架构（SOA）</h2><p>SOA ：面向服务的架构</p><p>当服务越来越多，容量的评估，小服务资源的浪费等问题逐渐显现，此时需增加一个调度中心基于访问压力实时管理集群容量，提高集群利用率。此时，用于提高机器利用率的资源调度和治理中心(SOA)是关键</p><p><img src="\blogPic\springcloud1\1525530804753.png" alt="1525530804753"></p><p>以前出现了什么问题？</p><ul><li>服务越来越多，需要管理每个服务的地址</li><li>调用关系错综复杂，难以理清依赖关系</li><li>服务过多，服务状态难以管理，无法根据服务情况动态管理</li></ul><p>服务治理要做什么？</p><ul><li>服务注册中心，实现服务自动注册和发现，无需人为记录服务地址</li><li>服务自动订阅，服务列表自动推送，服务调用透明化，无需关心依赖关系</li><li>动态监控服务状态监控报告，人为控制服务状态</li></ul><p>缺点：</p><ul><li>服务间会有依赖关系，一旦某个环节出错会影响较大</li><li>服务关系复杂，运维、测试部署困难，不符合DevOps思想</li></ul><h2 id="1-5-微服务"><a href="#1-5-微服务" class="headerlink" title="1.5.微服务"></a>1.5.微服务</h2><p>前面说的SOA，英文翻译过来是面向服务。微服务，似乎也是服务，都是对系统进行拆分。因此两者非常容易混淆，但其实缺有一些差别：</p><p>微服务的特点：</p><ul><li>单一职责：微服务中每一个服务都对应唯一的业务能力，做到单一职责</li><li>微：微服务的服务拆分粒度很小，例如一个用户管理就可以作为一个服务。每个服务虽小，但“五脏俱全”。</li><li>面向服务：面向服务是说每个服务都要对外暴露Rest风格服务接口API。并不关心服务的技术实现，做到与平台和语言无关，也不限定用什么技术实现，只要提供Rest的接口即可。</li><li>自治：自治是说服务间互相独立，互不干扰<ul><li>团队独立：每个服务都是一个独立的开发团队，人数不能过多。</li><li>技术独立：因为是面向服务，提供Rest接口，使用什么技术没有别人干涉</li><li>前后端分离：采用前后端分离开发，提供统一Rest接口，后端不用再为PC、移动段开发不同接口</li><li>数据库分离：每个服务都使用自己的数据源</li><li>部署独立，服务间虽然有调用，但要做到服务重启不影响其它服务。有利于持续集成和持续交付。每个服务都是独立的组件，可复用，可替换，降低耦合，易维护</li></ul></li></ul><p>微服务结构图：</p><p><img src="\blogPic\springcloud1\1526860071166.png" alt="1526860071166"></p><h1 id="2-服务调用方式"><a href="#2-服务调用方式" class="headerlink" title="2.服务调用方式"></a>2.服务调用方式</h1><h2 id="2-1-RPC和HTTP"><a href="#2-1-RPC和HTTP" class="headerlink" title="2.1.RPC和HTTP"></a>2.1.RPC和HTTP</h2><p>无论是微服务还是SOA，都面临着服务间的远程调用。那么服务间的远程调用方式有哪些呢？</p><p>常见的远程调用方式有以下2种：</p><ul><li><p>RPC：Remote Produce Call远程过程调用，类似的还有RMI。自定义数据格式，基于原生TCP通信，速度快，效率高。早期的webservice，现在热门的dubbo，都是RPC的典型代表</p></li><li><p>Http：http其实是一种网络传输协议，基于TCP，规定了数据传输的格式。现在客户端浏览器与服务端通信基本都是采用Http协议，也可以用来进行远程服务调用。缺点是消息封装臃肿，优势是对服务的提供和调用方没有任何技术限定，自由灵活，更符合微服务理念。</p><p>现在热门的Rest风格，就可以通过http协议来实现。</p></li></ul><p>如果你们公司全部采用Java技术栈，那么使用Dubbo作为微服务架构是一个不错的选择。</p><p>相反，如果公司的技术栈多样化，而且你更青睐Spring家族，那么SpringCloud搭建微服务是不二之选。在我们的项目中，我们会选择SpringCloud套件，因此我们会使用Http方式来实现服务间调用。</p><h2 id="2-2-Http客户端工具"><a href="#2-2-Http客户端工具" class="headerlink" title="2.2.Http客户端工具"></a>2.2.Http客户端工具</h2><p>既然微服务选择了Http，那么我们就需要考虑自己来实现对请求和响应的处理。不过开源世界已经有很多的http客户端工具，能够帮助我们做这些事情，例如：</p><ul><li>HttpClient</li><li>OKHttp</li><li>URLConnection</li></ul><p>接下来，不过这些不同的客户端，API各不相同，</p><h2 id="2-3-Spring的RestTemplate"><a href="#2-3-Spring的RestTemplate" class="headerlink" title="2.3.Spring的RestTemplate"></a>2.3.Spring的RestTemplate</h2><p>Spring提供了一个RestTemplate模板工具类，对基于Http的客户端进行了封装，并且实现了对象与json的序列化和反序列化，非常方便。RestTemplate并没有限定Http的客户端类型，而是进行了抽象，目前常用的3种都有支持：</p><ul><li>HttpClient</li><li>OkHttp</li><li>JDK原生的URLConnection（默认的）</li></ul><p>我们导入课前资料提供的demo工程：</p><p> <img src="\blogPic\springcloud1\1533686387565.png" alt="1533686387565"></p><p>首先在项目中注册一个<code>RestTemplate</code>对象，可以在启动类位置注册：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(HttpDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">   </span><br><span class="line"><span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在测试类中直接<code>@Autowired</code>注入：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = HttpDemoApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">HttpDemoApplicationTests</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Autowired</span></span><br><span class="line"><span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Test</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">httpGet</span><span class="params">()</span> </span>&#123;</span><br><span class="line">User user = <span class="keyword">this</span>.restTemplate.getForObject(<span class="string">"http://localhost/user/8"</span>, User.class);</span><br><span class="line">System.out.println(user);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过RestTemplate的getForObject()方法，传递url地址及实体类的字节码，RestTemplate会自动发起请求，接收响应，并且帮我们对响应结果进行反序列化。</li></ul><p><img src="\blogPic\springcloud1\1525573702492.png" alt="1525573702492"></p><p>学习完了Http客户端工具，接下来就可以正式学习微服务了。</p><h1 id="4-初始SpringCloud"><a href="#4-初始SpringCloud" class="headerlink" title="4.初始SpringCloud"></a>4.初始SpringCloud</h1><p>微服务是一种架构方式，最终肯定需要技术架构去实施。</p><p>微服务的实现方式很多，但是最火的莫过于Spring Cloud了。为什么？</p><ul><li>后台硬：作为Spring家族的一员，有整个Spring全家桶靠山，背景十分强大。</li><li>技术强：Spring作为Java领域的前辈，可以说是功力深厚。有强力的技术团队支撑，一般人还真比不了</li><li>群众基础好：可以说大多数程序员的成长都伴随着Spring框架，试问：现在有几家公司开发不用Spring？SpringCloud与Spring的各个框架无缝整合，对大家来说一切都是熟悉的配方，熟悉的味道。</li><li>使用方便：相信大家都体会到了SpringBoot给我们开发带来的便利，而SpringCloud完全支持SpringBoot的开发，用很少的配置就能完成微服务框架的搭建</li></ul><h2 id="4-1-简介"><a href="#4-1-简介" class="headerlink" title="4.1.简介"></a>4.1.简介</h2><p>SpringCloud是Spring旗下的项目之一，<a href="http://projects.spring.io/spring-cloud/" target="_blank" rel="noopener">官网地址：http://projects.spring.io/spring-cloud/</a></p><p>Spring最擅长的就是集成，把世界上最好的框架拿过来，集成到自己的项目中。</p><p>SpringCloud也是一样，它将现在非常流行的一些技术整合到一起，实现了诸如：配置管理，服务发现，智能路由，负载均衡，熔断器，控制总线，集群状态等等功能。其主要涉及的组件包括：</p><p>Netflix</p><ul><li>Eureka：注册中心</li><li>Zuul：服务网关</li><li>Ribbon：负载均衡</li><li>Feign：服务调用</li><li>Hystix：熔断器</li></ul><p>以上只是其中一部分，架构图：</p><p><img src="\blogPic\springcloud1\1525575656796.png" alt="1525575656796"></p><h2 id="4-2-版本"><a href="#4-2-版本" class="headerlink" title="4.2.版本"></a>4.2.版本</h2><p>SpringCloud的版本命名比较特殊，因为它不是一个组件，而是许多组件的集合，它的命名是以A到Z的为首字母的一些单词（其实是伦敦地铁站的名字）组成：</p><p> <img src="\blogPic\springcloud1\1533782406077.png" alt="1533782406077"></p><p>我们在项目中，会是以Finchley的版本。</p><p>其中包含的组件，也都有各自的版本，如下表：</p><table><thead><tr><th>Component</th><th>Edgware.SR4</th><th>Finchley.SR1</th><th>Finchley.BUILD-SNAPSHOT</th></tr></thead><tbody><tr><td>spring-cloud-aws</td><td>1.2.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-bus</td><td>1.3.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cli</td><td>1.4.1.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-commons</td><td>1.3.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-contract</td><td>1.2.5.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-config</td><td>1.4.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-netflix</td><td>1.4.5.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-security</td><td>1.2.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-cloudfoundry</td><td>1.1.2.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-consul</td><td>1.3.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-sleuth</td><td>1.3.4.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-stream</td><td>Ditmars.SR4</td><td>Elmhurst.SR1</td><td>Elmhurst.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-zookeeper</td><td>1.2.2.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-boot</td><td>1.5.14.RELEASE</td><td>2.0.4.RELEASE</td><td>2.0.4.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-task</td><td>1.2.3.RELEASE</td><td>2.0.0.RELEASE</td><td>2.0.1.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-vault</td><td>1.1.1.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-gateway</td><td>1.0.2.RELEASE</td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-openfeign</td><td></td><td>2.0.1.RELEASE</td><td>2.0.2.BUILD-SNAPSHOT</td></tr><tr><td>spring-cloud-function</td><td>1.0.0.RELEASE</td><td>1.0.0.RELEASE</td><td>1.0.1.BUILD-SNAPSHOT</td></tr></tbody></table><p>接下来，我们就一一学习SpringCloud中的重要组件。</p><h1 id="5-微服务场景模拟"><a href="#5-微服务场景模拟" class="headerlink" title="5.微服务场景模拟"></a>5.微服务场景模拟</h1><p>首先，我们需要模拟一个服务调用的场景。方便后面学习微服务架构</p><h2 id="5-1-创建父工程"><a href="#5-1-创建父工程" class="headerlink" title="5.1.创建父工程"></a>5.1.创建父工程</h2><p>微服务中需要同时创建多个项目，为了方便课堂演示，我们先创建一个父工程，然后后续的工程都以这个工程为父，实现maven的聚合。这样可以在一个窗口看到所有工程，方便我们讲解。<strong>在实际开发中，应该是每个微服务独立一个工程。</strong></p><p><img src="\blogPic\springcloud1\1529042834656.png" alt="1529042834656"></p><p>编写项目信息：</p><p> <img src="\blogPic\springcloud1\1529042868833.png" alt="1529042868833"></p><p>编写保存位置：</p><p><img src="\blogPic\springcloud1\1529042934471.png" alt="1529042934471"></p><p>然后将Pom修改成这样：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-parent<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>2.0.4.RELEASE<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">relativePath</span>/&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">properties</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.build.sourceEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.build.sourceEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">project.reporting.outputEncoding</span>&gt;</span>UTF-8<span class="tag">&lt;/<span class="name">project.reporting.outputEncoding</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">java.version</span>&gt;</span>1.8<span class="tag">&lt;/<span class="name">java.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">spring-cloud.version</span>&gt;</span>Finchley.SR1<span class="tag">&lt;/<span class="name">spring-cloud.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mapper.starter.version</span>&gt;</span>2.0.3<span class="tag">&lt;/<span class="name">mapper.starter.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">mysql.version</span>&gt;</span>5.1.32<span class="tag">&lt;/<span class="name">mysql.version</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">pageHelper.starter.version</span>&gt;</span>1.2.5<span class="tag">&lt;/<span class="name">pageHelper.starter.version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">properties</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- springCloud --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-dependencies<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;spring-cloud.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">type</span>&gt;</span>pom<span class="tag">&lt;/<span class="name">type</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">scope</span>&gt;</span>import<span class="tag">&lt;/<span class="name">scope</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 通用Mapper启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mapper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- 分页助手启动器 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>com.github.pagehelper<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>pagehelper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;pageHelper.starter.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="comment">&lt;!-- mysql驱动 --&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">version</span>&gt;</span>$&#123;mysql.version&#125;<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencyManagement</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.projectlombok<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>lombok<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">build</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">plugins</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">plugin</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-maven-plugin<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">plugin</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">plugins</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">build</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>这里已经对大部分要用到的依赖的版本进行了 管理，方便后续使用</p><h2 id="5-2-服务提供者"><a href="#5-2-服务提供者" class="headerlink" title="5.2.服务提供者"></a>5.2.服务提供者</h2><p>我们新建一个项目，对外提供查询用户的服务。</p><h3 id="5-2-1-创建module"><a href="#5-2-1-创建module" class="headerlink" title="5.2.1.创建module"></a>5.2.1.创建module</h3><p>选中父工程：cloud-demo</p><p> <img src="\blogPic\springcloud1\1533786389928.png" alt="1533786389928"></p><p>填写module信息：</p><p><img src="\blogPic\springcloud1\1529043293477.png" alt="1529043293477"></p><p>注意，子模块要在父工程的下级目录：</p><p><img src="\blogPic\springcloud1\1529043334927.png" alt="1529043334927"></p><h3 id="5-2-2-依赖"><a href="#5-2-2-依赖" class="headerlink" title="5.2.2.依赖"></a>5.2.2.依赖</h3><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>user-service<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>mysql<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mysql-connector-java<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>tk.mybatis<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>mapper-spring-boot-starter<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>项目结构：</p><p> <img src="\blogPic\springcloud1\1529043450850.png" alt="1529043450850"></p><h3 id="5-1-2-编写代码"><a href="#5-1-2-编写代码" class="headerlink" title="5.1.2.编写代码"></a>5.1.2.编写代码</h3><p>属性文件,这里我们采用了yaml语法，而不是properties：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/mydb01</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">cn.itcast.user.pojo</span></span><br></pre></td></tr></table></figure><p>启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"cn.itcast.user.mapper"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserApplication</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(UserApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Table</span>(name = <span class="string">"tb_user"</span>)</span><br><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Id</span></span><br><span class="line">    <span class="meta">@KeySql</span>(useGeneratedKeys = <span class="keyword">true</span>)</span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName; <span class="comment">// 用户名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;<span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sex;<span class="comment">// 性别，1男性，2女性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;<span class="comment">// 出生日期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date created;<span class="comment">// 创建时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date updated;<span class="comment">// 更新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String note;<span class="comment">// 备注</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>mapper:</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">interface</span> <span class="title">UserMapper</span> <span class="keyword">extends</span> <span class="title">Mapper</span>&lt;<span class="title">User</span>&gt;</span>&#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>Service：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>添加一个对外查询的接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"user"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserService userService;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"/&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> userService.queryById(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构：</p><p> <img src="\blogPic\springcloud1\1529043755485.png" alt="1529043755485"></p><h3 id="5-1-3-启动并测试："><a href="#5-1-3-启动并测试：" class="headerlink" title="5.1.3.启动并测试："></a>5.1.3.启动并测试：</h3><p>启动项目，访问接口：<a href="http://localhost:8081/user/7" target="_blank" rel="noopener">http://localhost:8081/user/7</a></p><p> <img src="\blogPic\springcloud1\1525593139364.png" alt="1525593139364"></p><h2 id="5-2-服务调用者"><a href="#5-2-服务调用者" class="headerlink" title="5.2.服务调用者"></a>5.2.服务调用者</h2><h3 id="5-2-1-创建工程"><a href="#5-2-1-创建工程" class="headerlink" title="5.2.1.创建工程"></a>5.2.1.创建工程</h3><p>与上面类似，这里不再赘述，需要注意的是，我们调用user-service的功能，因此不需要mybatis相关依赖了。</p><p><img src="\blogPic\springcloud1\1529043818258.png" alt="1529043818258"></p><p><img src="\blogPic\springcloud1\1529043876180.png" alt="1529043876180"></p><p>pom：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>consumer-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.boot<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-boot-starter-web<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>结构：</p><p> <img src="\blogPic\springcloud1\1529043945158.png" alt="1529043945158"></p><h3 id="5-2-2-编写代码"><a href="#5-2-2-编写代码" class="headerlink" title="5.2.2.编写代码"></a>5.2.2.编写代码</h3><p>首先在启动类中注册<code>RestTemplate</code>：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>实体类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Data</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">User</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Long id;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String userName; <span class="comment">// 用户名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String password; <span class="comment">// 密码</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;<span class="comment">// 姓名</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer age;<span class="comment">// 年龄</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Integer sex;<span class="comment">// 性别，1男性，2女性</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date birthday;<span class="comment">// 出生日期</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date created;<span class="comment">// 创建时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> Date updated;<span class="comment">// 更新时间</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String note;<span class="comment">// 备注</span></span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写controller，在controller中直接调用RestTemplate，远程访问user-service的服务接口：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        String url = <span class="string">"http://localhost:8081/user/"</span> + id;</span><br><span class="line">        User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>项目结构：</p><p> <img src="\blogPic\springcloud1\1533791573960.png" alt="1533791573960"></p><h3 id="5-2-3-启动测试："><a href="#5-2-3-启动测试：" class="headerlink" title="5.2.3.启动测试："></a>5.2.3.启动测试：</h3><p>因为我们没有配置端口，那么默认就是8080，我们访问：<a href="http://localhost:8080/consumer/8" target="_blank" rel="noopener">http://localhost:8080/consumer/8</a></p><p> <img src="\blogPic\springcloud1\1533792850467.png" alt="1533792850467"></p><p>一个简单的远程服务调用案例就实现了。</p><h2 id="5-3-有没有问题？"><a href="#5-3-有没有问题？" class="headerlink" title="5.3.有没有问题？"></a>5.3.有没有问题？</h2><p>简单回顾一下，刚才我们写了什么：</p><p>user-service：对外提供了查询用户的接口</p><p>consumer：通过RestTemplate访问<code>http://locahost:8081/user/{id}</code>接口，查询用户数据</p><p>存在什么问题？</p><ul><li>在consumer中，我们把url地址硬编码到了代码中，不方便后期维护</li><li>consumer需要记忆user-service的地址，如果出现变更，可能得不到通知，地址将失效</li><li>consumer不清楚user-service的状态，服务宕机也不知道</li><li>user-service只有1台服务，不具备高可用性</li><li>即便user-service形成集群，consumer还需自己实现负载均衡</li></ul><p>其实上面说的问题，概括一下就是分布式服务必然要面临的问题：</p><ul><li>服务管理<ul><li>如何自动注册和发现</li><li>如何实现状态监管</li><li>如何实现动态路由</li></ul></li><li>服务如何实现负载均衡</li><li>服务如何解决容灾问题</li><li>服务如何实现统一配置</li></ul><p>以上的问题，我们都将在SpringCloud中得到答案。</p><h1 id="6-Eureka注册中心"><a href="#6-Eureka注册中心" class="headerlink" title="6.Eureka注册中心"></a>6.Eureka注册中心</h1><h2 id="6-1-认识Eureka"><a href="#6-1-认识Eureka" class="headerlink" title="6.1.认识Eureka"></a>6.1.认识Eureka</h2><p>首先我们来解决第一问题，服务的管理。</p><blockquote><p>问题分析</p></blockquote><p>在刚才的案例中，user-service对外提供服务，需要对外暴露自己的地址。而consumer（调用者）需要记录服务提供者的地址。将来地址出现变更，还需要及时更新。这在服务较少的时候并不觉得有什么，但是在现在日益复杂的互联网环境，一个项目肯定会拆分出十几，甚至数十个微服务。此时如果还人为管理地址，不仅开发困难，将来测试、发布上线都会非常麻烦，这与DevOps的思想是背道而驰的。</p><blockquote><p>网约车</p></blockquote><p>这就好比是 网约车出现以前，人们出门叫车只能叫出租车。一些私家车想做出租却没有资格，被称为黑车。而很多人想要约车，但是无奈出租车太少，不方便。私家车很多却不敢拦，而且满大街的车，谁知道哪个才是愿意载人的。一个想要，一个愿意给，就是缺少引子，缺乏管理啊。</p><p>此时滴滴这样的网约车平台出现了，所有想载客的私家车全部到滴滴注册，记录你的车型（服务类型），身份信息（联系方式）。这样提供服务的私家车，在滴滴那里都能找到，一目了然。</p><p>此时要叫车的人，只需要打开APP，输入你的目的地，选择车型（服务类型），滴滴自动安排一个符合需求的车到你面前，为你服务，完美！</p><blockquote><p>Eureka做什么？</p></blockquote><p>Eureka就好比是滴滴，负责管理、记录服务提供者的信息。服务调用者无需自己寻找服务，而是把自己的需求告诉Eureka，然后Eureka会把符合你需求的服务告诉你。</p><p>同时，服务提供方与Eureka之间通过<code>“心跳”</code>机制进行监控，当某个服务提供方出现问题，Eureka自然会把它从服务列表中剔除。</p><p>这就实现了服务的自动注册、发现、状态监控。</p><h2 id="6-2-原理图"><a href="#6-2-原理图" class="headerlink" title="6.2.原理图"></a>6.2.原理图</h2><blockquote><p>基本架构：</p></blockquote><p> <img src="\blogPic\springcloud1\1525597885059.png" alt="1525597885059"></p><ul><li>Eureka：就是服务注册中心（可以是一个集群），对外暴露自己的地址</li><li>提供者：启动后向Eureka注册自己信息（地址，提供什么服务）</li><li>消费者：向Eureka订阅服务，Eureka会将对应服务的所有提供者地址列表发送给消费者，并且定期更新</li><li>心跳(续约)：提供者定期通过http方式向Eureka刷新自己的状态</li></ul><h2 id="6-3-入门案例"><a href="#6-3-入门案例" class="headerlink" title="6.3.入门案例"></a>6.3.入门案例</h2><h3 id="6-3-1-编写EurekaServer"><a href="#6-3-1-编写EurekaServer" class="headerlink" title="6.3.1.编写EurekaServer"></a>6.3.1.编写EurekaServer</h3><p>接下来我们创建一个项目，启动一个EurekaServer：</p><p> <img src="\blogPic\springcloud1\1529060127090.png" alt="1529060127090"></p><p> <img src="\blogPic\springcloud1\1529060143421.png" alt="1529060143421"></p><p>依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?xml version="1.0" encoding="UTF-8"?&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">project</span> <span class="attr">xmlns</span>=<span class="string">"http://maven.apache.org/POM/4.0.0"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xmlns:xsi</span>=<span class="string">"http://www.w3.org/2001/XMLSchema-instance"</span></span></span><br><span class="line"><span class="tag">         <span class="attr">xsi:schemaLocation</span>=<span class="string">"http://maven.apache.org/POM/4.0.0 http://maven.apache.org/xsd/maven-4.0.0.xsd"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">parent</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>cloud-demo<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">parent</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">modelVersion</span>&gt;</span>4.0.0<span class="tag">&lt;/<span class="name">modelVersion</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>cn.itcast.demo<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">version</span>&gt;</span>1.0-SNAPSHOT<span class="tag">&lt;/<span class="name">version</span>&gt;</span></span><br><span class="line"></span><br><span class="line">    <span class="tag">&lt;<span class="name">dependencies</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-server<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">dependencies</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">project</span>&gt;</span></span><br></pre></td></tr></table></figure><p>编写启动类：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableEurekaServer</span> <span class="comment">// 声明这个应用是一个EurekaServer</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">EurekaServer</span> </span>&#123;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(EurekaServer.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编写配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10086</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中作为服务的id标识（serviceId）</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span> <span class="comment"># EurekaServer的地址，现在是自己的地址，如果是集群，需要写其它Server的地址。</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>启动服务，并访问：<a href="http://127.0.0.1:10086/eureka" target="_blank" rel="noopener">http://127.0.0.1:10086/eureka</a></p><p><img src="\blogPic\springcloud1\1525604959508.png" alt="1525604959508"></p><p><img src="\blogPic\springcloud1\1533793804268.png" alt="1533793804268"></p><h3 id="6-3-2-服务注册"><a href="#6-3-2-服务注册" class="headerlink" title="6.3.2.服务注册"></a>6.3.2.服务注册</h3><p>注册服务，就是在服务上添加Eureka的客户端依赖，客户端代码会自动把服务注册到EurekaServer中。</p><blockquote><p>我们在user-service-demo中添加Eureka客户端依赖：</p></blockquote><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><blockquote><p>在启动类上开启Eureka客户端功能</p></blockquote><p>通过添加<code>@EnableDiscoveryClient</code>来开启Eureka客户端功能</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@MapperScan</span>(<span class="string">"cn.itcast.user.mapper"</span>)</span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启Eureka客户端发现功能</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserServiceDemoApplication</span> </span>&#123;</span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">SpringApplication.run(UserServiceDemoApplication.class, args);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>编写配置</p></blockquote><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8081</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  datasource:</span></span><br><span class="line"><span class="attr">    url:</span> <span class="attr">jdbc:mysql://localhost:3306/mydb01</span></span><br><span class="line"><span class="attr">    username:</span> <span class="string">root</span></span><br><span class="line"><span class="attr">    password:</span> <span class="number">123</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">user-service</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">mybatis:</span></span><br><span class="line"><span class="attr">  type-aliases-package:</span> <span class="string">com.leyou.userservice.pojo</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>注意：</p><ul><li>这里我们添加了spring.application.name属性来指定应用名称，将来会作为服务的id使用。</li></ul><blockquote><p>重启项目，访问<a href="http://127.0.0.1:10086/eureka" target="_blank" rel="noopener">Eureka监控页面</a>查看</p></blockquote><p><img src="\blogPic\springcloud1\1533793943618.png" alt="1533793943618"></p><p>我们发现user-service服务已经注册成功了</p><h3 id="6-3-3-服务发现"><a href="#6-3-3-服务发现" class="headerlink" title="6.3.3.服务发现"></a>6.3.3.服务发现</h3><p>接下来我们修改consumer-demo，尝试从EurekaServer获取服务。</p><p>方法与消费者类似，只需要在项目中添加EurekaClient依赖，就可以通过服务名称来获取信息了！</p><p>1）添加依赖：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- Eureka客户端 --&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-eureka-client<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><p>2）在启动类开启Eureka客户端</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span> <span class="comment">// 开启Eureka客户端</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="meta">@Bean</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line">        SpringApplication.run(ConsumerApplication.class, args);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>3）修改配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">8080</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">consumer</span> <span class="comment"># 应用名称</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span> <span class="comment"># EurekaServer地址</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>4）修改代码，用DiscoveryClient类的方法，根据服务名称，获取服务实例：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> DiscoveryClient discoveryClient;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        <span class="comment">// 根据服务id(spring.application.name)，获取服务实例列表</span></span><br><span class="line">        List&lt;ServiceInstance&gt; instances = discoveryClient.getInstances(<span class="string">"user-service"</span>);</span><br><span class="line">        <span class="comment">// 取出一个服务实例</span></span><br><span class="line">        ServiceInstance instance = instances.get(<span class="number">0</span>);</span><br><span class="line">        <span class="comment">// 从实例中获取host和port，组成url</span></span><br><span class="line">        String url = String.format(<span class="string">"http://%s:%s/user/%s"</span>, instance.getHost(), instance.getPort(), id);</span><br><span class="line">        <span class="comment">// 查询</span></span><br><span class="line">        User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>5）Debug跟踪运行：</p><p>生成的URL：</p><p> <img src="\blogPic\springcloud1\1533824658440.png" alt="1533824658440"></p><p>这里的ip是本机的局域网ip。</p><p>访问结果：</p><p> <img src="\blogPic\springcloud1\1533824695239.png" alt="1533824695239"></p><h2 id="6-4-Eureka详解"><a href="#6-4-Eureka详解" class="headerlink" title="6.4.Eureka详解"></a>6.4.Eureka详解</h2><p>接下来我们详细讲解Eureka的原理及配置。</p><h3 id="6-4-1-基础架构"><a href="#6-4-1-基础架构" class="headerlink" title="6.4.1.基础架构"></a>6.4.1.基础架构</h3><p>Eureka架构中的三个核心角色：</p><ul><li><p>服务注册中心</p><p>Eureka的服务端应用，提供服务注册和发现功能，就是刚刚我们建立的eureka-server</p></li><li><p>服务提供者</p><p>提供服务的应用，可以是SpringBoot应用，也可以是其它任意技术实现，只要对外提供的是Rest风格服务即可。本例中就是我们实现的user-service</p></li><li><p>服务消费者</p><p>消费应用从注册中心获取服务列表，从而得知每个服务方的信息，知道去哪里调用服务方。本例中就是我们实现的consumer</p></li></ul><h3 id="6-4-2-高可用的Eureka-Server"><a href="#6-4-2-高可用的Eureka-Server" class="headerlink" title="6.4.2.高可用的Eureka Server"></a>6.4.2.高可用的Eureka Server</h3><p>Eureka Server即服务的注册中心，在刚才的案例中，我们只有一个EurekaServer，事实上EurekaServer也可以是一个集群，形成高可用的Eureka中心。</p><blockquote><p>服务同步</p></blockquote><p>多个Eureka Server之间也会互相注册为服务，当服务提供者注册到Eureka Server集群中的某个节点时，该节点会把服务的信息同步给集群中的每个节点，从而实现<strong>数据同步</strong>。因此，无论客户端访问到Eureka Server集群中的任意一个节点，都可以获取到完整的服务列表信息。</p><p>而作为客户端，需要把信息注册到每个Eureka中：</p><p> <img src="\blogPic\springcloud1\1533825644505.png" alt="1533825644505"></p><p>如果有三个Eureka，则每一个EurekaServer都需要注册到其它几个Eureka服务中，例如：有三个分别为10086、10087、10088，则：</p><ul><li>10086要注册到10087和10088上</li><li>10087要注册到10086和10088上</li><li>10088要注册到10086和10087上</li></ul><blockquote><p>动手搭建高可用的EurekaServer</p></blockquote><p>我们假设要搭建两条EurekaServer的集群，端口分别为：10086和10087</p><p>1）我们修改原来的EurekaServer配置：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10086</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span> <span class="comment"># 配置其他Eureka服务的地址，而不是自己，比如10087</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure><p>所谓的高可用注册中心，其实就是把EurekaServer自己也作为一个服务，注册到其它EurekaServer上，这样多个EurekaServer之间就能互相发现对方，从而形成集群。因此我们做了以下修改：</p><ul><li>把service-url的值改成了另外一台EurekaServer的地址，而不是自己</li></ul><p>2）另外一台配置恰好相反：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">server:</span></span><br><span class="line"><span class="attr">  port:</span> <span class="number">10087</span> <span class="comment"># 端口</span></span><br><span class="line"><span class="attr">spring:</span></span><br><span class="line"><span class="attr">  application:</span></span><br><span class="line"><span class="attr">    name:</span> <span class="string">eureka-server</span> <span class="comment"># 应用名称，会在Eureka中显示</span></span><br><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span> </span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka</span></span><br></pre></td></tr></table></figure><p>注意：idea中一个应用不能启动两次，我们需要重新配置一个启动器：</p><p> <img src="\blogPic\springcloud1\1525615070033.png" alt="1525615070033"></p><p> <img src="\blogPic\springcloud1\1533825083030.png" alt="1533825083030"></p><p> <img src="\blogPic\springcloud1\1533825180015.png" alt="1533825180015"></p><p>然后启动即可。</p><p>3）启动测试：</p><p><img src="\blogPic\springcloud1\1533825779695.png" alt="1533825779695"></p><p>4）客户端注册服务到集群</p><p>因为EurekaServer不止一个，因此注册服务的时候，service-url参数需要变化：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    service-url:</span> <span class="comment"># EurekaServer地址,多个地址以','隔开</span></span><br><span class="line"><span class="attr">      defaultZone:</span> <span class="attr">http://127.0.0.1:10086/eureka,http://127.0.0.1:10087/eureka</span></span><br></pre></td></tr></table></figure><h3 id="6-4-3-Eureka客户端"><a href="#6-4-3-Eureka客户端" class="headerlink" title="6.4.3.Eureka客户端"></a>6.4.3.Eureka客户端</h3><p>服务提供者要向EurekaServer注册服务，并且完成服务续约等工作。</p><blockquote><p>服务注册</p></blockquote><p>服务提供者在启动时，会检测配置属性中的：<code>eureka.client.register-with-erueka=true</code>参数是否正确，事实上默认就是true。如果值确实为true，则会向EurekaServer发起一个Rest请求，并携带自己的元数据信息，Eureka Server会把这些信息保存到一个双层Map结构中。</p><ul><li>第一层Map的Key就是服务id，一般是配置中的<code>spring.application.name</code>属性</li><li>第二层Map的key是服务的实例id。一般host+ serviceId + port，例如：<code>locahost:user-service:8081</code></li><li>值则是服务的实例对象，也就是说一个服务，可以同时启动多个不同实例，形成集群。</li></ul><blockquote><p>服务续约</p></blockquote><p>在注册服务完成以后，服务提供者会维持一个心跳（定时向EurekaServer发起Rest请求），告诉EurekaServer：“我还活着”。这个我们称为服务的续约（renew）；</p><p>有两个重要参数可以修改服务续约的行为：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  instance:</span></span><br><span class="line"><span class="attr">    lease-expiration-duration-in-seconds:</span> <span class="number">90</span></span><br><span class="line"><span class="attr">    lease-renewal-interval-in-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><ul><li>lease-renewal-interval-in-seconds：服务续约(renew)的间隔，默认为30秒</li><li>lease-expiration-duration-in-seconds：服务失效时间，默认值90秒</li></ul><p>也就是说，默认情况下每个30秒服务会向注册中心发送一次心跳，证明自己还活着。如果超过90秒没有发送心跳，EurekaServer就会认为该服务宕机，会从服务列表中移除，这两个值在生产环境不要修改，默认即可。</p><blockquote><p>获取服务列表</p></blockquote><p>当服务消费者启动是，会检测<code>eureka.client.fetch-registry=true</code>参数的值，如果为true，则会从Eureka Server服务的列表只读备份，然后缓存在本地。并且<code>每隔30秒</code>会重新获取并更新数据。我们可以通过下面的参数来修改：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  client:</span></span><br><span class="line"><span class="attr">    registry-fetch-interval-seconds:</span> <span class="number">30</span></span><br></pre></td></tr></table></figure><h3 id="6-4-5-失效剔除和自我保护"><a href="#6-4-5-失效剔除和自我保护" class="headerlink" title="6.4.5.失效剔除和自我保护"></a>6.4.5.失效剔除和自我保护</h3><blockquote><p>服务下线</p></blockquote><p>当服务进行正常关闭操作时，它会触发一个服务下线的REST请求给Eureka Server，告诉服务注册中心：“我要下线了”。服务中心接受到请求之后，将该服务置为下线状态。</p><blockquote><p>失效剔除</p></blockquote><p>有时我们的服务可能由于内存溢出或网络故障等原因使得服务不能正常的工作，而服务注册中心并未收到“服务下线”的请求。相对于服务提供者的“服务续约”操作，服务注册中心在启动时会创建一个定时任务，默认每隔一段时间（默认为60秒）将当前清单中超时（默认为90秒）没有续约的服务剔除，这个操作被称为失效剔除。</p><p>可以通过<code>eureka.server.eviction-interval-timer-in-ms</code>参数对其进行修改，单位是毫秒。</p><blockquote><p>自我保护</p></blockquote><p>我们关停一个服务，就会在Eureka面板看到一条警告：</p><p><img src="\blogPic\springcloud1\1525618396076.png" alt="1525618396076"></p><p>这是触发了Eureka的自我保护机制。当服务未按时进行心跳续约时，Eureka会统计服务实例最近15分钟心跳续约的比例是否低于了85%。在生产环境下，因为网络延迟等原因，心跳失败实例的比例很有可能超标，但是此时就把服务剔除列表并不妥当，因为服务可能没有宕机。Eureka在这段时间内不会剔除任何服务实例，直到网络恢复正常。生产环境下这很有效，保证了大多数服务依然可用，不过也有可能获取到失败的服务实例，因此服务调用者必须做好服务的失败容错。</p><p>我们可以通过下面的配置来关停自我保护：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">eureka:</span></span><br><span class="line"><span class="attr">  server:</span></span><br><span class="line"><span class="attr">    enable-self-preservation:</span> <span class="literal">false</span> <span class="comment"># 关闭自我保护模式（缺省为打开）</span></span><br></pre></td></tr></table></figure><h1 id="7-负载均衡Ribbon"><a href="#7-负载均衡Ribbon" class="headerlink" title="7.负载均衡Ribbon"></a>7.负载均衡Ribbon</h1><p>在刚才的案例中，我们启 动了一个user-service，然后通过DiscoveryClient来获取服务实例信息，然后获取ip和端口来访问。</p><p>但是实际环境中，我们往往会开启很多个user-service的集群。此时我们获取的服务列表中就会有多个，到底该访问哪一个呢？</p><p>一般这种情况下我们就需要编写负载均衡算法，在多个实例列表中进行选择。</p><p>不过Eureka中已经帮我们集成了负载均衡组件：Ribbon，简单修改代码即可使用。</p><p>什么是Ribbon：</p><p><img src="\blogPic\springcloud1\1525619257397.png" alt="1525619257397"></p><p>接下来，我们就来使用Ribbon实现负载均衡。</p><h2 id="7-1-启动两个服务实例"><a href="#7-1-启动两个服务实例" class="headerlink" title="7.1.启动两个服务实例"></a>7.1.启动两个服务实例</h2><p>首先我们启动两个user-service实例，一个8081，一个8082。</p><p> <img src="\blogPic\springcloud1\1533826535457.png" alt="1533826535457"></p><p>Eureka监控面板：</p><p><img src="\blogPic\springcloud1\1533826564383.png" alt="1533826564383"></p><h2 id="7-2-开启负载均衡"><a href="#7-2-开启负载均衡" class="headerlink" title="7.2.开启负载均衡"></a>7.2.开启负载均衡</h2><p>因为Eureka中已经集成了Ribbon，所以我们无需引入新的依赖。直接修改代码：</p><p>在RestTemplate的配置方法上添加<code>@LoadBalanced</code>注解：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Bean</span></span><br><span class="line"><span class="meta">@LoadBalanced</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> RestTemplate <span class="title">restTemplate</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> RestTemplate();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>修改调用方式，不再手动获取ip和端口，而是直接通过服务名称调用：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    String url = <span class="string">"http://user-service/user/"</span> + id;</span><br><span class="line">    User user = restTemplate.getForObject(url, User.class);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>访问页面，查看结果：</p><p> <img src="\blogPic\springcloud1\1533824695239.png" alt="1533824695239"></p><p>完美！</p><h2 id="7-3-源码跟踪"><a href="#7-3-源码跟踪" class="headerlink" title="7.3.源码跟踪"></a>7.3.源码跟踪</h2><p>为什么我们只输入了service名称就可以访问了呢？之前还要获取ip和端口。</p><p>显然有人帮我们根据service名称，获取到了服务实例的ip和端口。它就是<code>LoadBalancerInterceptor</code>，这个类会在对RestTemplate的请求进行拦截，然后从Eureka根据服务id获取服务列表，随后利用负载均衡算法得到真实的服务地址信息，替换服务id。</p><p>我们进行源码跟踪：</p><p><img src="\blogPic\springcloud1\1525620483637.png" alt="1525620483637"></p><p>继续跟入execute方法：发现获取了8082端口的服务</p><p><img src="\blogPic\springcloud1\1525620787090.png" alt="1525620787090"></p><p>再跟下一次，发现获取的是8081：</p><p> <img src="\blogPic\springcloud1\1525620835911.png" alt="1525620835911"></p><p>果然实现了负载均衡。</p><h2 id="7-4-负载均衡策略"><a href="#7-4-负载均衡策略" class="headerlink" title="7.4.负载均衡策略"></a>7.4.负载均衡策略</h2><p>Ribbon默认的负载均衡策略是简单的轮询，我们可以测试一下：</p><p>编写测试类，在刚才的源码中我们看到拦截中是使用RibbonLoadBalanceClient来进行负载均衡的，其中有一个choose方法，是这样介绍的：</p><p> <img src="\blogPic\springcloud1\1525622320277.png" alt="1525622320277"></p><p>现在这个就是负载均衡获取实例的方法。</p><p>我们对注入这个类的对象，然后对其测试：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RunWith</span>(SpringRunner.class)</span><br><span class="line"><span class="meta">@SpringBootTest</span>(classes = UserConsumerDemoApplication.class)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">LoadBalanceTest</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    RibbonLoadBalancerClient client;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Test</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">100</span>; i++) &#123;</span><br><span class="line">            ServiceInstance instance = <span class="keyword">this</span>.client.choose(<span class="string">"user-service"</span>);</span><br><span class="line">            System.out.println(instance.getHost() + <span class="string">":"</span> + instance.getPort());</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>结果：</p><p> <img src="\blogPic\springcloud1\1525622357371.png" alt="1525622357371"></p><p>符合了我们的预期推测，确实是轮询方式。</p><p>我们是否可以修改负载均衡的策略呢？</p><p>我们注入的RibbonLoadBalancerClient的choose方法如下：</p><p><img src="\blogPic\springcloud1\1533827364555.png" alt="1533827364555"></p><p>它会调用getServer方法：</p><p><img src="\blogPic\springcloud1\1533827421778.png" alt="1533827421778"></p><p>getServer中，会先获取一个IloadBalancer对象，然后调用其chooseServer方法。IloadBalancer是一个接口，这里通过端点得知，这里是其中一个实现：BaseLoadBalancer。</p><p>继续跟踪源码，发现这么一段代码：</p><p> <img src="\blogPic\springcloud1\1525622652849.png" alt="1525622652849"></p><p>我们看看这个rule是谁：</p><p> <img src="\blogPic\springcloud1\1525622699666.png" alt="1525622699666"></p><p>这里的rule默认值是一个<code>RoundRobinRule</code>，看类的介绍：</p><p> <img src="\blogPic\springcloud1\1525622754316.png" alt="1525622754316"></p><p>这不就是轮询的意思嘛。</p><p>我们注意到，这个类其实是实现了接口IRule的，查看一下：</p><p> <img src="\blogPic\springcloud1\1525622817451.png" alt="1525622817451"></p><p>定义负载均衡的规则接口。</p><p>它有以下实现：</p><p> <img src="\blogPic\springcloud1\1525622876842.png" alt="1525622876842"></p><p>SpringBoot也帮我们提供了修改负载均衡规则的配置入口：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">user-service:</span></span><br><span class="line"><span class="attr">  ribbon:</span></span><br><span class="line"><span class="attr">    NFLoadBalancerRuleClassName:</span> <span class="string">com.netflix.loadbalancer.RandomRule</span></span><br></pre></td></tr></table></figure><p>格式是：<code>{服务名称}.ribbon.NFLoadBalancerRuleClassName</code>，值就是IRule的实现类。</p><p>再次测试，发现结果变成了随机：</p><p> <img src="\blogPic\springcloud1\1525623193949.png" alt="1525623193949"></p><h1 id="8-Hystrix"><a href="#8-Hystrix" class="headerlink" title="8.Hystrix"></a>8.Hystrix</h1><h2 id="8-1-简介"><a href="#8-1-简介" class="headerlink" title="8.1.简介"></a>8.1.简介</h2><p>Hystix,英文意思是豪猪，全身是刺，看起来就不好惹，是一种保护机制。</p><p>Hystrix也是Netflix公司的一款组件。</p><p>主页：<a href="https://github.com/Netflix/Hystrix/" target="_blank" rel="noopener">https://github.com/Netflix/Hystrix/</a></p><p><img src="\blogPic\springcloud1\1525658740266.png" alt="1525658740266"></p><p>那么Hystix的作用是什么呢？具体要保护什么呢？</p><p>Hystix是Netflix开源的一个延迟和容错库，用于隔离访问远程服务、第三方库，防止出现级联失败。</p><h2 id="8-2-雪崩问题"><a href="#8-2-雪崩问题" class="headerlink" title="8.2.雪崩问题"></a>8.2.雪崩问题</h2><p>微服务中，服务间调用关系错综复杂，一个请求，可能需要调用多个微服务接口才能实现，会形成非常复杂的调用链路：</p><p> <img src="\blogPic\springcloud1\1533829099748.png" alt="1533829099748"></p><p>如图，一次业务请求，需要调用A、P、H、I四个服务，这四个服务又可能调用其它服务。</p><p>如果此时，某个服务出现异常：</p><p> <img src="\blogPic\springcloud1\1533829198240.png" alt="1533829198240"></p><p>例如微服务I发生异常，请求阻塞，用户不会得到响应，则tomcat的这个线程不会释放，于是越来越多的用户请求到来，越来越多的线程会阻塞：</p><p> <img src="\blogPic\springcloud1\1533829307389.png" alt="1533829307389"></p><p>服务器支持的线程和并发数有限，请求一直阻塞，会导致服务器资源耗尽，从而导致所有其它服务都不可用，形成雪崩效应。</p><p>这就好比，一个汽车生产线，生产不同的汽车，需要使用不同的零件，如果某个零件因为种种原因无法使用，那么就会造成整台车无法装配，陷入等待零件的状态，直到零件到位，才能继续组装。  此时如果有很多个车型都需要这个零件，那么整个工厂都将陷入等待的状态，导致所有生产都陷入瘫痪。一个零件的波及范围不断扩大。 </p><p>Hystix解决雪崩问题的手段有两个：</p><ul><li>线程隔离</li><li>服务熔断</li></ul><h2 id="8-3-线程隔离，服务降级"><a href="#8-3-线程隔离，服务降级" class="headerlink" title="8.3.线程隔离，服务降级"></a>8.3.线程隔离，服务降级</h2><h3 id="8-3-1-原理"><a href="#8-3-1-原理" class="headerlink" title="8.3.1.原理"></a>8.3.1.原理</h3><p>线程隔离示意图：</p><p> <img src="\blogPic\springcloud1\1533829598310.png" alt="1533829598310"></p><p>解读：</p><p>Hystrix为每个依赖服务调用分配一个小的线程池，如果线程池已满调用将被立即拒绝，默认不采用排队.加速失败判定时间。</p><p>用户的请求将不再直接访问服务，而是通过线程池中的空闲线程来访问服务，如果<strong>线程池已满</strong>，或者<strong>请求超时</strong>，则会进行降级处理，什么是服务降级？</p><blockquote><p>服务降级：优先保证核心服务，而非核心服务不可用或弱可用。</p></blockquote><p>用户的请求故障时，不会被阻塞，更不会无休止的等待或者看到系统崩溃，至少可以看到一个执行结果（例如返回友好的提示信息） 。</p><p>服务降级虽然会导致请求失败，但是不会导致阻塞，而且最多会影响这个依赖服务对应的线程池中的资源，对其它服务没有响应。</p><p>触发Hystix服务降级的情况：</p><ul><li>线程池已满</li><li>请求超时</li></ul><h3 id="8-3-2-动手实践"><a href="#8-3-2-动手实践" class="headerlink" title="8.3.2.动手实践"></a>8.3.2.动手实践</h3><h4 id="引入依赖："><a href="#引入依赖：" class="headerlink" title="引入依赖："></a>引入依赖：</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">dependency</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">groupId</span>&gt;</span>org.springframework.cloud<span class="tag">&lt;/<span class="name">groupId</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">artifactId</span>&gt;</span>spring-cloud-starter-netflix-hystrix<span class="tag">&lt;/<span class="name">artifactId</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">dependency</span>&gt;</span></span><br></pre></td></tr></table></figure><h4 id="开启熔断："><a href="#开启熔断：" class="headerlink" title="开启熔断："></a>开启熔断：</h4><p>在启动类上添加注解：@EnableCircuitBreaker</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringBootApplication</span></span><br><span class="line"><span class="meta">@EnableDiscoveryClient</span></span><br><span class="line"><span class="meta">@EnableCircuitBreaker</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line"><span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到，我们类上的注解越来越多，在微服务中，经常会引入上面的三个注解，于是Spring就提供了一个组合注解：@SpringCloudApplication</p><p>  <img src="\blogPic\springcloud1\1533856086255.png" alt="1533856086255"></p><p>因此，我们可以使用这个组合注解来代替之前的3个注解。</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@SpringCloudApplication</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerApplication</span> </span>&#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="编写降级逻辑"><a href="#编写降级逻辑" class="headerlink" title="编写降级逻辑"></a>编写降级逻辑</h4><p>当目标服务的调用出现故障，我们希望快速失败，给用户一个友好提示。因此需要提前编写好失败时的降级处理逻辑，要使用HystixCommond来完成：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span>(fallbackMethod = <span class="string">"queryByIdFallBack"</span>)</span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    String url = <span class="string">"http://user-service/user/"</span> + id;</span><br><span class="line">    String user = restTemplate.getForObject(url, String.class);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryByIdFallBack</span><span class="params">(Long id)</span></span>&#123;</span><br><span class="line">    log.error(<span class="string">"查询用户信息失败，id：&#123;&#125;"</span>, id);</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"对不起，网络太拥挤了！"</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>要注意，因为熔断的降级逻辑方法必须跟正常逻辑方法保证：<strong>相同的参数列表和返回值声明</strong>。失败逻辑中返回User对象没有太大意义，一般会返回友好提示。所以我们把queryById的方法改造为返回String，反正也是Json数据。这样失败逻辑中返回一个错误说明，会比较方便。</p><p>说明：</p><ul><li>@HystrixCommand(fallbackMethod = “queryByIdFallBack”)：用来声明一个降级逻辑的方法</li></ul><p>测试：</p><p>当user-service正常提供服务时，访问与以前一致。但是当我们将user-service停机时，会发现页面返回了降级处理信息：</p><p><img src="\blogPic\springcloud1\1533857268880.png" alt="1533857268880"></p><h4 id="默认的Fallback"><a href="#默认的Fallback" class="headerlink" title="默认的Fallback"></a>默认的Fallback</h4><p>我们刚才把fallback写在了某个业务方法上，如果这样的方法很多，那岂不是要写很多。所以我们可以把Fallback配置加在类上，实现默认fallback：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@RestController</span></span><br><span class="line"><span class="meta">@RequestMapping</span>(<span class="string">"consumer"</span>)</span><br><span class="line"><span class="meta">@DefaultProperties</span>(defaultFallback = <span class="string">"defaultFallBack"</span>)</span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ConsumerController</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> RestTemplate restTemplate;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line">    <span class="meta">@HystrixCommand</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">        String url = <span class="string">"http://user-service/user/"</span> + id;</span><br><span class="line">        String user = restTemplate.getForObject(url, String.class);</span><br><span class="line">        <span class="keyword">return</span> user;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">defaultFallBack</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">"默认提示：对不起，网络太拥挤了！"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>@DefaultProperties(defaultFallback = “defaultFallBack”)：在类上指明统一的失败降级方法</li></ul><p><img src="\blogPic\springcloud1\1533858138646.png" alt="1533858138646"></p><h4 id="超时设置："><a href="#超时设置：" class="headerlink" title="超时设置："></a>超时设置：</h4><p>在之前的案例中，请求在超过1秒后都会返回错误信息，这是因为Hystix的默认超时时长为1，我们可以通过配置修改这个值：</p><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="attr">hystrix:</span></span><br><span class="line"><span class="attr">  command:</span></span><br><span class="line"><span class="attr">    default:</span></span><br><span class="line"><span class="attr">      execution:</span></span><br><span class="line"><span class="attr">        isolation:</span></span><br><span class="line"><span class="attr">          thread:</span></span><br><span class="line"><span class="attr">            timeoutInMilliseconds:</span> <span class="number">2000</span></span><br></pre></td></tr></table></figure><p>这个配置会作用于全局所有方法。</p><p>为了触发超时，我们可以在user-service中休眠2秒：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Service</span></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">UserService</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Autowired</span></span><br><span class="line">    <span class="keyword">private</span> UserMapper userMapper;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> User <span class="title">queryById</span><span class="params">(Long id)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">            Thread.sleep(<span class="number">2000</span>);</span><br><span class="line">        &#125; <span class="keyword">catch</span> (InterruptedException e) &#123;</span><br><span class="line">            e.printStackTrace();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> userMapper.selectByPrimaryKey(id);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>测试：</p><p><img src="\blogPic\springcloud1\1533858701825.png" alt="1533858701825"></p><p>可以发现，请求的时长已经到了2.01s，证明配置生效了。</p><p>如果把修改时间修改到2秒以下，又可以正常访问了。</p><h2 id="8-4-服务熔断："><a href="#8-4-服务熔断：" class="headerlink" title="8.4.服务熔断："></a>8.4.服务熔断：</h2><h3 id="8-4-1-熔断原理"><a href="#8-4-1-熔断原理" class="headerlink" title="8.4.1.熔断原理"></a>8.4.1.熔断原理</h3><p>熔断器，也叫断路器，其英文单词为：Circuit Breaker </p><p><img src="\blogPic\springcloud1\1525658640314.png" alt="1525658640314"></p><p>Hystix的熔断状态机模型：</p><p><img src="\blogPic\springcloud1\1533830345149.png" alt="1533830345149"></p><p>状态机有3个状态：</p><ul><li>Open：打开状态，所有请求都正常访问。</li><li>Closed：关闭状态，所有请求都会被降级。Hystix会对请求情况计数，当一定时间内失败请求百分比达到阈值，则触发熔断，断路器会完全关闭。默认失败比例的阈值是50%，请求次数最少不低于20次。</li><li>Half Open：半开状态，Closed状态不是永久的，关闭后会进入休眠时间（默认是5S）。随后断路器会自动进入半开状态。此时会释放部分请求通过，若这些请求都是健康的，则会完全打开断路器，否则继续保持关闭，再次进行休眠计时</li></ul><h3 id="8-4-2-动手实践"><a href="#8-4-2-动手实践" class="headerlink" title="8.4.2.动手实践"></a>8.4.2.动手实践</h3><p>为了能够精确控制请求的成功或失败，我们在consumer的调用业务中加入一段逻辑：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@GetMapping</span>(<span class="string">"&#123;id&#125;"</span>)</span><br><span class="line"><span class="meta">@HystrixCommand</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> String <span class="title">queryById</span><span class="params">(@PathVariable(<span class="string">"id"</span>)</span> Long id)</span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(id == <span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> RuntimeException(<span class="string">"太忙了"</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    String url = <span class="string">"http://user-service/user/"</span> + id;</span><br><span class="line">    String user = restTemplate.getForObject(url, String.class);</span><br><span class="line">    <span class="keyword">return</span> user;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这样如果参数是id为1，一定失败，其它情况都成功。（不要忘了清空user-service中的休眠逻辑）</p><p>我们准备两个请求窗口：</p><ul><li>一个请求：<a href="http://localhost:8080/consumer/1，注定失败" target="_blank" rel="noopener">http://localhost:8080/consumer/1，注定失败</a></li><li>一个请求：<a href="http://localhost:8080/consumer/2，肯定成功" target="_blank" rel="noopener">http://localhost:8080/consumer/2，肯定成功</a></li></ul><p>当我们疯狂访问id为1的请求时（超过20次），就会触发熔断。断路器会端口，一切请求都会被降级处理。</p><p>此时你访问id为2的请求，会发现返回的也是失败，而且失败时间很短，只有20毫秒左右：</p><p><img src="\blogPic\springcloud1\1533859591238.png" alt="1533859591238"></p><p>不过，默认的熔断触发要求较高，休眠时间窗较短，为了测试方便，我们可以通过配置修改熔断策略：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">circuitBreaker.requestVolumeThreshold=10</span><br><span class="line">circuitBreaker.sleepWindowInMilliseconds=10000</span><br><span class="line">circuitBreaker.errorThresholdPercentage=50</span><br></pre></td></tr></table></figure><p>解读：</p><ul><li>requestVolumeThreshold：触发熔断的最小请求次数，默认20</li><li>errorThresholdPercentage：触发熔断的失败请求最小占比，默认50%</li><li>sleepWindowInMilliseconds：休眠时长，默认是5000毫秒</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringCloud基础学习&quot;&gt;&lt;a href=&quot;#SpringCloud基础学习&quot; class=&quot;headerlink&quot; title=&quot;SpringCloud基础学习&quot;&gt;&lt;/a&gt;SpringCloud基础学习&lt;/h1&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>Spring全家桶总结</title>
    <link href="http://yoursite.com/2019/01/12/Spring%E5%85%A8%E5%AE%B6%E6%A1%B6%E6%80%BB%E7%BB%93/"/>
    <id>http://yoursite.com/2019/01/12/Spring全家桶总结/</id>
    <published>2019-01-12T14:46:19.000Z</published>
    <updated>2019-01-12T14:50:35.967Z</updated>
    
    <content type="html"><![CDATA[<p>简介：这是针对Spring全家桶系列的总结，后面会陆续添加更新<br><a id="more"></a></p><h1 id="Spring"><a href="#Spring" class="headerlink" title="Spring"></a>Spring</h1><h1 id="SpringMVC"><a href="#SpringMVC" class="headerlink" title="SpringMVC"></a>SpringMVC</h1><h1 id="SSM综合"><a href="#SSM综合" class="headerlink" title="SSM综合"></a>SSM综合</h1><h1 id="SpringBoot"><a href="#SpringBoot" class="headerlink" title="SpringBoot"></a>SpringBoot</h1><h1 id="SpringCloud"><a href="#SpringCloud" class="headerlink" title="SpringCloud"></a>SpringCloud</h1>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;简介：这是针对Spring全家桶系列的总结，后面会陆续添加更新&lt;br&gt;
    
    </summary>
    
    
      <category term="技术" scheme="http://yoursite.com/tags/%E6%8A%80%E6%9C%AF/"/>
    
  </entry>
  
  <entry>
    <title>SpringMVC_study</title>
    <link href="http://yoursite.com/2019/01/09/SpringMVC-study/"/>
    <id>http://yoursite.com/2019/01/09/SpringMVC-study/</id>
    <published>2019-01-09T13:03:28.000Z</published>
    <updated>2019-01-17T04:32:55.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="SpringMVC的学习"><a href="#SpringMVC的学习" class="headerlink" title="SpringMVC的学习"></a>SpringMVC的学习</h1><a id="more"></a><h3 id="sublime使用"><a href="#sublime使用" class="headerlink" title="sublime使用"></a>sublime使用</h3><p>sublime真是编辑器之神，安装install package,然后安装插件 pretty json cmd+ctrl+j格式化json数据。</p><h3 id="SpringMVC流程图"><a href="#SpringMVC流程图" class="headerlink" title="SpringMVC流程图"></a>SpringMVC流程图</h3><h5 id="mvc简易模型图"><a href="#mvc简易模型图" class="headerlink" title="mvc简易模型图"></a>mvc简易模型图</h5><p><img src="\blogPic\springmvc\mvcmodel1.png" alt="mvc1"></p><h5 id="mvc框架结构"><a href="#mvc框架结构" class="headerlink" title="mvc框架结构"></a>mvc框架结构</h5><p><img src="\blogPic\springmvc\mvcmodel2.png" alt="mvc2"></p><p><img src="\blogPic\springmvc\mvcmodel3.png" alt="mvc2"></p><h3 id="springmvc相关内容"><a href="#springmvc相关内容" class="headerlink" title="springmvc相关内容"></a>springmvc相关内容</h3><h4 id="springmvc的使用步骤"><a href="#springmvc的使用步骤" class="headerlink" title="springmvc的使用步骤"></a>springmvc的使用步骤</h4><ol><li>配置web.xml：<br>配置前端控制器：tomcat启动时初始化、指定springmvc的配置文件的位置</li><li>编写springmvc的配置文件：<br>开启包扫描<br>配置视图解析器：指定如果去查找视图</li><li>编写自定义处理器<br>将处理器装配到容器中<br>编写请求的url映射关系：@RequestMapping(“xxx”):来映射要执行的方法<br>在@RequestMapping(“xxx”)下编写方法处理具体的业务逻辑，返回一个ModelAndView，其中可以封装视图名称和数据。</li></ol><h4 id="RequestMapping映射请求"><a href="#RequestMapping映射请求" class="headerlink" title="RequestMapping映射请求"></a>RequestMapping映射请求</h4><ul><li>标准URL映射</li><li>Ant风格的映射：*(0个或多个字符)、？(单个字符)、**(0个或多个路径)</li><li>Rest风格的映射：占位符</li><li>限定请求方法的映射：get、post、put、delete</li><li>限定参数的映射：限定哪些请求参数可以访问</li></ul><h4 id="使用json"><a href="#使用json" class="headerlink" title="使用json"></a>使用json</h4><h5 id="响应json数据"><a href="#响应json数据" class="headerlink" title="响应json数据"></a>响应json数据</h5><p>@ResponseBody：<br>当一个处理请求的方法标记为@ResponseBody时，表示该方法需要输出其他视图（json、xml），springmvc会通过默认的json转化器转化输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">* 将list集合响应成json数据</span><br><span class="line">* @return</span><br><span class="line">*/</span><br><span class="line">@RequestMapping(value=&quot;show28&quot;)</span><br><span class="line">@ResponseBody//将数据响应成json格式的数据</span><br><span class="line">public List&lt;User&gt; test28() &#123;</span><br><span class="line"> List&lt;User&gt; list = new ArrayList&lt;User&gt;();</span><br><span class="line"> for(int i = 0;i&lt; 20;i++) &#123;</span><br><span class="line">  User user = new User();</span><br><span class="line">  user.setId(i+1L);</span><br><span class="line">  user.setUsername(&quot;zhangsan&quot;+i);</span><br><span class="line">  user.setName(&quot;张三&quot;+i);</span><br><span class="line">  user.setAge(18);</span><br><span class="line">  list.add(user);</span><br><span class="line">  &#125;</span><br><span class="line">  return list;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><p>在使用jackson转换json数据时需要消息转换器HttpMessageConverter的支持，该消息转换器默认并没有开启。</p><p>在配置文件中注册注解驱动：配置该标签后会自动注册消息转换器。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置注解驱动--&gt;</span><br><span class="line">&lt;mvc:annotation-driven&gt;&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure><h5 id="使用pojo接收json数据"><a href="#使用pojo接收json数据" class="headerlink" title="使用pojo接收json数据"></a>使用pojo接收json数据</h5><p>@RequestBody：接收一个json并且转换成一个对象。<br>接收一个json数据并反序列化为一个user对象。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line">  * 将提交的json格式的数据封装到user对象中</span><br><span class="line"> * @RequestBody()：自动将json数据序列化成一个user对象</span><br><span class="line"> * @param model</span><br><span class="line"> * @param user</span><br><span class="line"> * @return</span><br><span class="line"> */</span><br><span class="line"> @RequestMapping(value=&quot;show29&quot;)</span><br><span class="line"> public String test29(Model model,@RequestBody User</span><br><span class="line"> user) &#123;</span><br><span class="line">  model.addAttribute(&quot;msg&quot;, user);</span><br><span class="line">  return &quot;hello&quot;;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure><h5 id="解决中文乱码问题"><a href="#解决中文乱码问题" class="headerlink" title="解决中文乱码问题"></a>解决中文乱码问题</h5><p>原因:使用的消息转换器换成了StringHttpMessageConverter，<br>该转换器中使用的默认的编码为ISO_8859_1：</p><p>解决方案:<br>    修改消息转换器中的编码集</p><p>将注解驱动修改如下：</p><ol><li>设置String的消息转换器</li><li>该消息转换器中有一个构造函数可以设置编码集，因此只要直接赋值即可。</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置注解驱动--&gt;</span><br><span class="line">&lt;mvc:annotation-driven&gt;</span><br><span class="line">    &lt;mvc:message-converters&gt;</span><br><span class="line">        &lt;bean class=&quot;org.springframework.http.converter.StringHttpMessageConverter&quot;&gt;</span><br><span class="line">            &lt;constructor-arg index=&quot;0&quot; value=&quot;utf-8&quot;&gt;&lt;/constructor-arg&gt;</span><br><span class="line">        &lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:message-converters&gt;</span><br><span class="line">&lt;/mvc:annotation-driven&gt;</span><br></pre></td></tr></table></figure><h4 id="RestController"><a href="#RestController" class="headerlink" title="@RestController"></a>@RestController</h4><p>有时如果在一个Contoller中所有的方法都是用来响应json格式数据的，那么如果有多个方法，就需要在多个方法上使用@ResponseBody，这样太麻烦，springmvc提供了一个@RestController，将该注解使用在Controller类上，那么该controller中的所有方法都默认是响应json格式的数据了。</p><h4 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h4><h5 id="步骤一：添加依赖"><a href="#步骤一：添加依赖" class="headerlink" title="步骤一：添加依赖"></a>步骤一：添加依赖</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;!-- 文件上传 --&gt;</span><br><span class="line">&lt;dependency&gt;</span><br><span class="line">    &lt;groupId&gt;commons-fileupload&lt;/groupId&gt;</span><br><span class="line">    &lt;artifactId&gt;commons-fileupload&lt;/artifactId&gt;</span><br><span class="line">    &lt;version&gt;1.3.1&lt;/version&gt;</span><br><span class="line">&lt;/dependency&gt;</span><br></pre></td></tr></table></figure><h5 id="步骤二：配置文件上传解析器"><a href="#步骤二：配置文件上传解析器" class="headerlink" title="步骤二：配置文件上传解析器"></a>步骤二：配置文件上传解析器</h5><p>需要在springmvc的配置文件中配置一个文件上传解析器（在spring-web包下），并且设置其解析器的某些参数，如上传文件大小和编码集等。</p><p>在springmvc-servlet.xml中配置：<br>注意：必须配置id属性，并且名称固定为multipartResolver，否则无法使用.</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置文件上传解析器--&gt;</span><br><span class="line">&lt;bean id=&quot;multipartResolver&quot; class=&quot;org.springframework.web.multipart.commons.CommonsMultipartResolver&quot;&gt;</span><br><span class="line">    &lt;!--设置上传文件大小--&gt;</span><br><span class="line">    &lt;property name=&quot;maxUploadSize&quot; value=&quot;5242880&quot;&gt;&lt;/property&gt;</span><br><span class="line">    &lt;!--设置上传文件编码集--&gt;</span><br><span class="line">    &lt;property name=&quot;defaultEncoding&quot; value=&quot;utf-8&quot;&gt;&lt;/property&gt;</span><br><span class="line">&lt;/bean&gt;</span><br></pre></td></tr></table></figure><h5 id="步骤三：Controller方法"><a href="#步骤三：Controller方法" class="headerlink" title="步骤三：Controller方法"></a>步骤三：Controller方法</h5><p>注意:存放文件的目录upload需要先行创建好</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * 文件上传</span><br><span class="line"> * 需要通过MultipartFile类型来接收上传数据</span><br><span class="line"> *</span><br><span class="line"> * @throws Exception</span><br><span class="line"> * @throws IllegalStateException</span><br><span class="line"> */</span><br><span class="line">@RequestMapping(&quot;show31&quot;)</span><br><span class="line">public String test31(Model model,@RequestParam(&quot;file&quot;)MultipartFile file) throws Exception&#123;</span><br><span class="line"></span><br><span class="line">    if (file!=null) &#123;</span><br><span class="line">        //将文件存储到指定路径</span><br><span class="line">        file.transferTo(new File(&quot;d://upload//&quot;+file.getOriginalFilename()));</span><br><span class="line">    &#125;</span><br><span class="line">    model.addAttribute(&quot;msg&quot;, &quot;上传成功!&quot;);</span><br><span class="line">    return &quot;hello&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="转发及重定向（forward、redirect）"><a href="#转发及重定向（forward、redirect）" class="headerlink" title="转发及重定向（forward、redirect）"></a>转发及重定向（forward、redirect）</h4><p>返回值为字符串时，默认为视图名称。当返回值字符串是以”forward:”或者”redirect:”开头，则会被认为是转发或者重定向。<br>使用方式如下：<br>转发：forward:/hello/show.do(绝对路径)或者forward:show.do(相对路径)<br>重定向：redirect:/hello/show.do(绝对路径)或者redirect:show.do(相对路径)<br>/：表示绝对路径，指的是localhost:8080/springmvc（项目名称可以省略）<br>不带/：表示相对路径，相对于当前请求的路径<br>    如果当前请求是：localhost:8080/springmvc（项目名称可以省略）/hello/show32<br>    那么不带/：表示localhost:8080/springmvc（项目名称可以省略）/hello/</p><h4 id="拦截器"><a href="#拦截器" class="headerlink" title="拦截器"></a>拦截器</h4><p>HandlerExecutionChain是一个执行链，当请求到达DispatchServlet时，DispatchServlet根据请求路径到HandlerMapping查询具体的Handler，从HandlerMapping返回执行链给DispatcherServlet，其中包含了一个具体的Handler对象和Interceptors（拦截器集合）。</p><p>拦截器一般用于对处理器进行预处理和后处理。</p><p>应用场景：</p><p>1、权限检查：如登录检测，进入处理器前检测用户是否登录，如果没有登陆直接返回到登录页面。</p><p>2、性能监控：有时候系统在某段时间莫名其妙的慢，可以通过拦截器在进入处理器之前记录开始时间，在处理完后记录结束时间，统计处理器执行使用了多少时间。</p><p>springmvc的拦截器接口（HandlerInterceptor）定义了三个方法：</p><ul><li>preHandle调用Handler之前执行，称为预处理回调方法<br>返回值：true表示放行，后续业务逻辑继续执行<pre><code>false表示被拦截，后续业务逻辑不再执行，但之前返回true的拦截器的请求完成回调方法会倒叙执行</code></pre></li><li>postHandle调用Handler之后执行，称为后处理回调方法</li><li>afterCompletion视图渲染完成之后执行，可以称为请求完成回调方法</li></ul><h5 id="拦截器的执行过程"><a href="#拦截器的执行过程" class="headerlink" title="拦截器的执行过程"></a>拦截器的执行过程</h5><p><img src="\blogPic\springmvc\intercepter1.png" alt="intercepter1"></p><p><img src="\blogPic\springmvc\intercepter2.png" alt="intercepter2"> </p><p>拦截器的配置过程：</p><p>编写自定义拦截器实现HandlerInterceptor<br>在springmvc-servlet.xml中注册自定义拦截器</p><h6 id="配置自定义拦截器"><a href="#配置自定义拦截器" class="headerlink" title="配置自定义拦截器"></a>配置自定义拦截器</h6><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--配置拦截器--&gt;</span><br><span class="line">&lt;mvc:interceptors&gt;</span><br><span class="line">    &lt;mvc:interceptor&gt;</span><br><span class="line">        &lt;!--拦截所有请求--&gt;</span><br><span class="line">        &lt;mvc:mapping path=&quot;/**&quot;/&gt;</span><br><span class="line">        &lt;bean class=&quot;cn.itcast.interceptor.MyInterceptor1&quot;&gt;&lt;/bean&gt;</span><br><span class="line">    &lt;/mvc:interceptor&gt;</span><br><span class="line">&lt;/mvc:interceptors&gt;</span><br></pre></td></tr></table></figure><h4 id="配置乱码过滤器"><a href="#配置乱码过滤器" class="headerlink" title="配置乱码过滤器"></a>配置乱码过滤器</h4><h5 id="POST"><a href="#POST" class="headerlink" title="POST"></a>POST</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;!--post请求乱码过滤器--&gt;</span><br><span class="line">&lt;filter&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;filter-class&gt;org.springframework.web.filter.CharacterEncodingFilter&lt;/filter-class&gt;</span><br><span class="line">    &lt;init-param&gt;</span><br><span class="line">        &lt;param-name&gt;encoding&lt;/param-name&gt;</span><br><span class="line">        &lt;param-value&gt;utf-8&lt;/param-value&gt;</span><br><span class="line">    &lt;/init-param&gt;</span><br><span class="line">&lt;/filter&gt;</span><br><span class="line">&lt;filter-mapping&gt;</span><br><span class="line">    &lt;filter-name&gt;characterEncodingFilter&lt;/filter-name&gt;</span><br><span class="line">    &lt;url-pattern&gt;/*&lt;/url-pattern&gt;</span><br><span class="line">&lt;/filter-mapping&gt;</span><br></pre></td></tr></table></figure><h5 id="GET"><a href="#GET" class="headerlink" title="GET"></a>GET</h5><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">&lt;plugins&gt;</span><br><span class="line">    &lt;!-- 配置Tomcat插件 --&gt;</span><br><span class="line">    &lt;plugin&gt;</span><br><span class="line">        &lt;groupId&gt;org.apache.tomcat.maven&lt;/groupId&gt;</span><br><span class="line">        &lt;artifactId&gt;tomcat7-maven-plugin&lt;/artifactId&gt;</span><br><span class="line">        &lt;configuration&gt;</span><br><span class="line">            &lt;port&gt;8080&lt;/port&gt;</span><br><span class="line">            &lt;path&gt;/&lt;/path&gt;&lt;!-- 相当于工程名称，一旦配置了/，那么在访问时可以省略工程名称 --&gt;</span><br><span class="line">            &lt;!--设置get请求编码集--&gt;</span><br><span class="line">            &lt;uriEncoding&gt;utf-8&lt;/uriEncoding&gt;</span><br><span class="line">        &lt;/configuration&gt;</span><br><span class="line">    &lt;/plugin&gt;</span><br><span class="line">&lt;/plugins&gt;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;SpringMVC的学习&quot;&gt;&lt;a href=&quot;#SpringMVC的学习&quot; class=&quot;headerlink&quot; title=&quot;SpringMVC的学习&quot;&gt;&lt;/a&gt;SpringMVC的学习&lt;/h1&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>markdown</title>
    <link href="http://yoursite.com/2019/01/09/markdown/"/>
    <id>http://yoursite.com/2019/01/09/markdown/</id>
    <published>2019-01-09T08:17:06.000Z</published>
    <updated>2019-01-17T03:05:07.863Z</updated>
    
    <content type="html"><![CDATA[<h1 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h1><blockquote><p>本博客为markdown的学习<br><a id="more"></a></p></blockquote><h1 id="markdown常用语法："><a href="#markdown常用语法：" class="headerlink" title="markdown常用语法："></a>markdown常用语法：</h1><p>使用   #</p><h1 id="一级标题"><a href="#一级标题" class="headerlink" title="一级标题:"></a>一级标题:</h1><p>#</p><h2 id="二级标题："><a href="#二级标题：" class="headerlink" title="二级标题："></a>二级标题：</h2><p>##</p><h3 id="三级标题："><a href="#三级标题：" class="headerlink" title="三级标题："></a>三级标题：</h3><p> ###</p><h4 id="四级标题"><a href="#四级标题" class="headerlink" title="四级标题:"></a>四级标题:</h4><p>####</p><h5 id="五级标题："><a href="#五级标题：" class="headerlink" title="五级标题："></a>五级标题：</h5><p>#####</p><h6 id="六级标题："><a href="#六级标题：" class="headerlink" title="六级标题："></a>六级标题：</h6><p>######</p><h3 id="无序列表-（后面加空格）"><a href="#无序列表-（后面加空格）" class="headerlink" title="无序列表: -（后面加空格）"></a>无序列表: -（后面加空格）</h3><ul><li style="list-style: none"><input type="checkbox"> 文本1：</li><li style="list-style: none"><input type="checkbox"> 文本2：</li><li style="list-style: none"><input type="checkbox"> 文本3：</li></ul><h3 id="水平线-后面不加空格-，一个-是水平线，三个-是水平虚线"><a href="#水平线-后面不加空格-，一个-是水平线，三个-是水平虚线" class="headerlink" title="水平线: -(后面不加空格)，一个-是水平线，三个-是水平虚线"></a>水平线: -(后面不加空格)，一个-是水平线，三个-是水平虚线</h3><h2 id=""><a href="#" class="headerlink" title="-"></a>-</h2><h3 id="有序列表-1"><a href="#有序列表-1" class="headerlink" title="有序列表:1."></a>有序列表:1.</h3><ol><li>文本1：1.</li><li>文本2：2.</li><li>文本3：3.</li></ol><h3 id="插入链接：-显示文本-链接地址"><a href="#插入链接：-显示文本-链接地址" class="headerlink" title="插入链接：[显示文本](链接地址)"></a>插入链接：[显示文本](链接地址)</h3><p><a href="http://www.baidu.com" target="_blank" rel="noopener">百度</a></p><h3 id="图片链接-图片-图片地址"><a href="#图片链接-图片-图片地址" class="headerlink" title="图片链接: ![图片](图片地址)"></a>图片链接: ![图片](图片地址)</h3><p><img src="\blogPic\markdown\girl.jpg" alt="美女"></p><h3 id="引用：在希望引用的文字前加上-gt-就好了"><a href="#引用：在希望引用的文字前加上-gt-就好了" class="headerlink" title="引用：在希望引用的文字前加上 &gt; 就好了"></a>引用：在希望引用的文字前加上 &gt; 就好了</h3><blockquote><p>一盏灯， 一片昏黄； 一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。  </p></blockquote><h3 id="粗体和斜体：两个-包含就是粗体，一个-就是斜体"><a href="#粗体和斜体：两个-包含就是粗体，一个-就是斜体" class="headerlink" title="粗体和斜体：两个 * 包含就是粗体，一个* 就是斜体"></a>粗体和斜体：两个 * 包含就是粗体，一个* 就是斜体</h3><p><strong>一盏灯</strong>，一片昏黄：一简书， 一杯淡茶。 守着那一份淡定， 品读属于自己的寂寞。 保持淡定， 才能欣赏到最美丽的风景！ 保持淡定， 人生从此不再寂寞。</p><h3 id="代码引用：如果只有一段，不分行，可以用-将语句包起来；如果一用分为多行，可以将-置于这段代码的首行和末行"><a href="#代码引用：如果只有一段，不分行，可以用-将语句包起来；如果一用分为多行，可以将-置于这段代码的首行和末行" class="headerlink" title="代码引用：如果只有一段，不分行，可以用 `将语句包起来；如果一用分为多行，可以将```置于这段代码的首行和末行"></a>代码引用：如果只有一段，不分行，可以用 `将语句包起来；如果一用分为多行，可以将```置于这段代码的首行和末行</h3><p><code>hello world</code><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">第一段代码</span><br><span class="line">第二段代码</span><br><span class="line">第三段代码</span><br></pre></td></tr></table></figure></p><h3 id="表格"><a href="#表格" class="headerlink" title="表格"></a>表格</h3><p><img src="\blogPic\markdown\biaoge.png" alt="tupian"></p><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$2</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><table><thead><tr><th>Tables</th><th style="text-align:center">Are</th><th style="text-align:right">Cool</th></tr></thead><tbody><tr><td>col 3 is</td><td style="text-align:center">right-aligned</td><td style="text-align:right">$1600</td></tr><tr><td>col 2 is</td><td style="text-align:center">centered</td><td style="text-align:right">$12</td></tr><tr><td>zebra stripes</td><td style="text-align:center">are neat</td><td style="text-align:right">$1</td></tr></tbody></table><table><thead><tr><th>dog</th><th>bird</th><th>cat</th></tr></thead><tbody><tr><td>foo</td><td>foo</td><td>foo</td></tr><tr><td>bar</td><td>bar</td><td>bar</td></tr><tr><td>baz</td><td>baz</td><td>baz</td></tr></tbody></table><h3 id="转义字符："><a href="#转义字符：" class="headerlink" title="转义字符： \"></a>转义字符： \</h3><p>#,\,`,*,_,{},[],(),+,-,.,!</p><h3 id="居中：-lt-center-lt-center"><a href="#居中：-lt-center-lt-center" class="headerlink" title="居中：&lt;center>  &lt;/center>"></a>居中：&lt;center>  &lt;/center></h3><center>居中</center>]]></content>
    
    <summary type="html">
    
      &lt;h1 id=&quot;摘要&quot;&gt;&lt;a href=&quot;#摘要&quot; class=&quot;headerlink&quot; title=&quot;摘要&quot;&gt;&lt;/a&gt;摘要&lt;/h1&gt;&lt;blockquote&gt;
&lt;p&gt;本博客为markdown的学习&lt;br&gt;
    
    </summary>
    
    
  </entry>
  
  <entry>
    <title>Welcome</title>
    <link href="http://yoursite.com/2019/01/06/Welcome/"/>
    <id>http://yoursite.com/2019/01/06/Welcome/</id>
    <published>2019-01-06T12:48:44.000Z</published>
    <updated>2019-01-09T07:46:41.375Z</updated>
    
    <content type="html"><![CDATA[<h1 id="欢迎来到我的博客"><a href="#欢迎来到我的博客" class="headerlink" title="欢迎来到我的博客"></a><center>欢迎来到我的博客</center></h1>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;欢迎来到我的博客&quot;&gt;&lt;a href=&quot;#欢迎来到我的博客&quot; class=&quot;headerlink&quot; title=&quot;欢迎来到我的博客&quot;&gt;&lt;/a&gt;&lt;center&gt;欢迎来到我的博客&lt;/center&gt;&lt;/h1&gt;
      
    
    </summary>
    
    
  </entry>
  
</feed>
